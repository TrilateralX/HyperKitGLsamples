// Generated by Haxe 4.3.0-rc.1+88ebbd0
(function ($hx_exports, $global) { "use strict";
$hx_exports["hxGeomAlgo"] = $hx_exports["hxGeomAlgo"] || {};
$hx_exports["hxGeomAlgo"]["_HxPoint"] = $hx_exports["hxGeomAlgo"]["_HxPoint"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:"fracs.DifferencePreference",__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:"haxe.ds.Either",__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var hxGeomAlgo_HomogCoord = function(x,y,w) {
	if(w == null) {
		w = 1;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.w = w;
};
hxGeomAlgo_HomogCoord.__name__ = true;
var hxGeomAlgo_HxPointData = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
hxGeomAlgo_HxPointData.__name__ = true;
var hxGeomAlgo_HxPoint = $hx_exports["hxGeomAlgo"]["HxPoint"] = {};
hxGeomAlgo_HxPoint.get_x = function(this1) {
	return this1.x;
};
hxGeomAlgo_HxPoint.set_x = function(this1,value) {
	return this1.x = value;
};
hxGeomAlgo_HxPoint.get_y = function(this1) {
	return this1.y;
};
hxGeomAlgo_HxPoint.set_y = function(this1,value) {
	return this1.y = value;
};
hxGeomAlgo_HxPoint._new = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var this1 = new hxGeomAlgo_HxPointData(x,y);
	return this1;
};
hxGeomAlgo_HxPoint.setTo = function(this1,newX,newY) {
	this1.x = newX;
	this1.y = newY;
};
hxGeomAlgo_HxPoint.equals = function(this1,p) {
	if(p != null && this1.x == p.x) {
		return this1.y == p.y;
	} else {
		return false;
	}
};
hxGeomAlgo_HxPoint.clone = function(this1) {
	return hxGeomAlgo_HxPoint._new(this1.x,this1.y);
};
hxGeomAlgo_HxPoint.toString = function(this1) {
	return "(" + this1.x + ", " + this1.y + ")";
};
hxGeomAlgo_HxPoint.fromPointStruct = function(p) {
	return hxGeomAlgo_HxPoint._new(p.x,p.y);
};
hxGeomAlgo_HxPoint.toPointStruct = function(this1) {
	return { x : this1.x, y : this1.y};
};
var hxGeomAlgo_PolyTools = $hx_exports["hxGeomAlgo"]["PolyTools"] = function() { };
hxGeomAlgo_PolyTools.__name__ = true;
hxGeomAlgo_PolyTools.isCCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea < 0;
};
hxGeomAlgo_PolyTools.isCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea > 0;
};
hxGeomAlgo_PolyTools.makeCCW = function(poly) {
	var reversed = false;
	if(!hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.makeCW = function(poly) {
	var reversed = false;
	if(hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.isConvex = function(poly) {
	var isPositive = null;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var lower = i == 0 ? poly.length - 1 : i - 1;
		var middle = i;
		var upper = i == poly.length - 1 ? 0 : i + 1;
		var dx0 = poly[middle].x - poly[lower].x;
		var dy0 = poly[middle].y - poly[lower].y;
		var dx1 = poly[upper].x - poly[middle].x;
		var dy1 = poly[upper].y - poly[middle].y;
		var cross = dx0 * dy1 - dx1 * dy0;
		var newIsPositive = cross > 0;
		if(cross == 0) {
			continue;
		}
		if(isPositive == null) {
			isPositive = newIsPositive;
		} else if(isPositive != newIsPositive) {
			return false;
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.isSimple = function(poly) {
	var len = poly.length;
	if(len <= 3) {
		return true;
	}
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = i;
		var p1 = i == len - 1 ? 0 : i + 1;
		var _g2 = i + 1;
		var _g3 = len;
		while(_g2 < _g3) {
			var j = _g2++;
			var q0 = j;
			var q1 = j == len - 1 ? 0 : j + 1;
			var intersection = hxGeomAlgo_PolyTools.segmentIntersect(poly[p0],poly[p1],poly[q0],poly[q1]);
			var tmp;
			var tmp1;
			if(intersection != null) {
				var tmp2;
				var w = poly[p0];
				var x = intersection.x - w.x;
				var x1 = intersection.y - w.y;
				if(!(Math.sqrt(x * x + x1 * x1) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w1 = poly[p1];
					var x2 = intersection.x - w1.x;
					var x3 = intersection.y - w1.y;
					tmp2 = Math.sqrt(x2 * x2 + x3 * x3) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp2 = true;
				}
				tmp1 = !tmp2;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var tmp3;
				var w2 = poly[q0];
				var x4 = intersection.x - w2.x;
				var x5 = intersection.y - w2.y;
				if(!(Math.sqrt(x4 * x4 + x5 * x5) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w3 = poly[q1];
					var x6 = intersection.x - w3.x;
					var x7 = intersection.y - w3.y;
					tmp3 = Math.sqrt(x6 * x6 + x7 * x7) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp3 = true;
				}
				tmp = !tmp3;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.segmentIntersect = function(p0,p1,q0,q1) {
	var a1 = p1.y - p0.y;
	var b1 = p0.x - p1.x;
	var c1 = p1.x * p0.y - p0.x * p1.y;
	var a2 = q1.y - q0.y;
	var b2 = q0.x - q1.x;
	var c2 = q1.x * q0.y - q0.x * q1.y;
	var denom = a1 * b2 - a2 * b1;
	if(denom == 0) {
		return null;
	}
	var intersectionPoint = hxGeomAlgo_HxPoint._new();
	intersectionPoint.x = (b1 * c2 - b2 * c1) / denom;
	intersectionPoint.y = (a2 * c1 - a1 * c2) / denom;
	var x = p0.x - p1.x;
	var x1 = p0.y - p1.y;
	var p0p1 = x * x + x1 * x1;
	var x = q0.x - q1.x;
	var x1 = q0.y - q1.y;
	var q0q1 = x * x + x1 * x1;
	var x = intersectionPoint.x - p1.x;
	var x1 = intersectionPoint.y - p1.y;
	if(x * x + x1 * x1 > p0p1) {
		return null;
	}
	var x = intersectionPoint.x - p0.x;
	var x1 = intersectionPoint.y - p0.y;
	if(x * x + x1 * x1 > p0p1) {
		return null;
	}
	var x = intersectionPoint.x - q1.x;
	var x1 = intersectionPoint.y - q1.y;
	if(x * x + x1 * x1 > q0q1) {
		return null;
	}
	var x = intersectionPoint.x - q0.x;
	var x1 = intersectionPoint.y - q0.y;
	if(x * x + x1 * x1 > q0q1) {
		return null;
	}
	return intersectionPoint;
};
hxGeomAlgo_PolyTools.findDuplicatePoints = function(poly,consecutiveOnly,wrapAround) {
	if(wrapAround == null) {
		wrapAround = true;
	}
	if(consecutiveOnly == null) {
		consecutiveOnly = true;
	}
	var len = poly.length;
	if(len <= 1) {
		return [];
	}
	var dupIndices = [];
	var _g = 0;
	var _g1 = len - 1;
	while(_g < _g1) {
		var i = _g++;
		var j = i + 1;
		while(j < len) {
			var this1 = poly[i];
			var p = poly[j];
			var foundDup = p != null && this1.x == p.x && this1.y == p.y;
			if(foundDup) {
				dupIndices.push(i);
			}
			if(consecutiveOnly || foundDup && !consecutiveOnly) {
				break;
			}
			++j;
		}
	}
	var tmp;
	if(wrapAround && consecutiveOnly) {
		var this1 = poly[0];
		var p = poly[len - 1];
		tmp = p != null && this1.x == p.x && this1.y == p.y;
	} else {
		tmp = false;
	}
	if(tmp) {
		dupIndices.push(len - 1);
	}
	return dupIndices;
};
hxGeomAlgo_PolyTools.intersection = function(p1,p2,q1,q2) {
	var res = null;
	var a1 = p2.y - p1.y;
	var b1 = p1.x - p2.x;
	var c1 = a1 * p1.x + b1 * p1.y;
	var a2 = q2.y - q1.y;
	var b2 = q1.x - q2.x;
	var c2 = a2 * q1.x + b2 * q1.y;
	var det = a1 * b2 - a2 * b1;
	if(!(Math.abs(det) <= hxGeomAlgo_PolyTools.EPSILON)) {
		res = hxGeomAlgo_HxPoint._new();
		res.x = (b2 * c1 - b1 * c2) / det;
		res.y = (a1 * c2 - a2 * c1) / det;
	}
	return res;
};
hxGeomAlgo_PolyTools.isReflex = function(poly,idx) {
	var idx1 = idx - 1;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var p = poly[idx1];
	var idx1 = idx;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var a = poly[idx1];
	var idx1 = idx + 1;
	var idx = idx1;
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	idx1 = idx % len;
	var b = poly[idx1];
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.at = function(poly,idx) {
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	return poly[idx];
};
hxGeomAlgo_PolyTools.wrappedIdx = function(poly,idx) {
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	return idx % len;
};
hxGeomAlgo_PolyTools.side = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y);
};
hxGeomAlgo_PolyTools.isLeft = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0;
};
hxGeomAlgo_PolyTools.isLeftOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) >= 0;
};
hxGeomAlgo_PolyTools.isRight = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.isRightOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) <= 0;
};
hxGeomAlgo_PolyTools.isCollinear = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) == 0;
};
hxGeomAlgo_PolyTools.distance = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return Math.sqrt(x * x + x1 * x1);
};
hxGeomAlgo_PolyTools.distanceToSegment = function(p,v,w) {
	return Math.sqrt(hxGeomAlgo_PolyTools.distanceToSegmentSquared(p,v,w));
};
hxGeomAlgo_PolyTools.distanceSquared = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.distanceToSegmentSquared = function(p,v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	var l2 = x * x + x1 * x1;
	if(l2 == 0) {
		var x = p.x - v.x;
		var x1 = p.y - v.y;
		return x * x + x1 * x1;
	}
	var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	if(t < 0) {
		var x = p.x - v.x;
		var x1 = p.y - v.y;
		return x * x + x1 * x1;
	}
	if(t > 1) {
		var x = p.x - w.x;
		var x1 = p.y - w.y;
		return x * x + x1 * x1;
	}
	hxGeomAlgo_HxPoint.setTo(hxGeomAlgo_PolyTools.point,v.x + t * (w.x - v.x),v.y + t * (w.y - v.y));
	var w = hxGeomAlgo_PolyTools.point;
	var x = p.x - w.x;
	var x1 = p.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.getCentroid = function(poly) {
	var c = hxGeomAlgo_HxPoint._new();
	var area = hxGeomAlgo_PolyTools.getArea(poly);
	if(area != 0) {
		var len = poly.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var p0 = poly[i];
			var p1 = poly[(i + 1) % len];
			var m = p0.x * p1.y - p1.x * p0.y;
			c.x += (p0.x + p1.x) * m;
			c.y += (p0.y + p1.y) * m;
		}
		c.x /= 6 * area;
		c.y /= 6 * area;
	} else {
		c = hxGeomAlgo_HxPoint.EMPTY;
	}
	return c;
};
hxGeomAlgo_PolyTools.getArea = function(poly) {
	var area = 0.0;
	var len = poly.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = poly[i];
		var p1 = poly[(i + 1) % len];
		area += p0.x * p1.y - p1.x * p0.y;
	}
	area = .5 * area;
	return area;
};
hxGeomAlgo_PolyTools.meet = function(p,q) {
	return new hxGeomAlgo_HomogCoord(p.y - q.y,q.x - p.x,p.x * q.y - p.y * q.x);
};
hxGeomAlgo_PolyTools.dot = function(p,q) {
	return p.x * q.x + p.y * q.y;
};
hxGeomAlgo_PolyTools.sqr = function(x) {
	return x * x;
};
hxGeomAlgo_PolyTools.eq = function(a,b) {
	return Math.abs(a - b) <= hxGeomAlgo_PolyTools.EPSILON;
};
hxGeomAlgo_PolyTools.clear = function(array) {
	array.length = 0;
};
hxGeomAlgo_PolyTools.toFloatArray = function(poly,out) {
	if(out == null) {
		out = [];
	}
	var _g = 0;
	while(_g < poly.length) {
		var p = poly[_g];
		++_g;
		out.push(p.x);
		out.push(p.y);
	}
	return out;
};
hxGeomAlgo_PolyTools.reverseFloatArray = function(poly,inPlace) {
	if(inPlace == null) {
		inPlace = false;
	}
	var res = inPlace ? poly : [];
	var nPoints = poly.length >> 1;
	var _g = 0;
	var _g1 = nPoints;
	while(_g < _g1) {
		var i = _g++;
		var xPos = (nPoints - i - 1) * 2;
		res[i * 2] = poly[xPos];
		res[i * 2 + 1] = poly[xPos + 1];
	}
	return res;
};
hxGeomAlgo_PolyTools.flatten = function(array,out) {
	var res = out != null ? out : [];
	var _g = 0;
	while(_g < array.length) {
		var arr = array[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < arr.length) {
			var item = arr[_g1];
			++_g1;
			res.push(item);
		}
	}
	return res;
};
hxGeomAlgo_PolyTools.toPointArray = function(poly,out) {
	if(out == null) {
		out = [];
	}
	var size = poly.length;
	if(poly.length % 2 == 1) {
		--size;
	}
	var _g = 0;
	var _g1 = size >> 1;
	while(_g < _g1) {
		var i = _g++;
		out.push(hxGeomAlgo_HxPoint._new(poly[i * 2],poly[i * 2 + 1]));
	}
	return out;
};
hxGeomAlgo_PolyTools.inflateLine = function(start,end,thickness) {
	var halfWidth = thickness / 2;
	var dx = end.x - start.x;
	var dy = end.y - start.y;
	var len = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / len * halfWidth;
	var ny = dy / len * halfWidth;
	return [hxGeomAlgo_HxPoint._new(start.x - ny,start.y + nx),hxGeomAlgo_HxPoint._new(end.x - ny,end.y + nx),hxGeomAlgo_HxPoint._new(end.x + ny,end.y - nx),hxGeomAlgo_HxPoint._new(start.x + ny,start.y - nx)];
};
hxGeomAlgo_PolyTools.clip = function(subjPoly,clipPoly) {
	var cond = clipPoly.length >= 3 && hxGeomAlgo_PolyTools.isConvex(clipPoly);
	var res = [];
	var output = subjPoly;
	var isInside = hxGeomAlgo_PolyTools.isCCW(clipPoly) ? hxGeomAlgo_PolyTools.isRight : hxGeomAlgo_PolyTools.isLeft;
	var clipEdgeStart;
	var clipEdgeEnd;
	var inputEdgeStart;
	var inputEdgeEnd;
	var clipLen = clipPoly.length;
	var i = 0;
	var _g = 0;
	var _g1 = clipLen;
	while(_g < _g1) {
		var i = _g++;
		clipEdgeStart = clipPoly[i];
		var idx = i + 1;
		var len = clipPoly.length;
		if(idx < 0) {
			idx += len;
		}
		clipEdgeEnd = clipPoly[idx % len];
		var input = output;
		output = [];
		inputEdgeStart = input[input.length - 1];
		var _g2 = 0;
		var _g3 = input.length;
		while(_g2 < _g3) {
			var j = _g2++;
			inputEdgeEnd = input[j];
			if(isInside(inputEdgeEnd,clipEdgeStart,clipEdgeEnd)) {
				if(!isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
					var intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
					if(intersectionPoint != null) {
						output.push(intersectionPoint);
					}
				}
				output.push(inputEdgeEnd);
			} else if(isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
				var intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
				if(intersectionPoint1 != null) {
					output.push(intersectionPoint1);
				}
			}
			inputEdgeStart = inputEdgeEnd;
		}
		res.push(output);
	}
	return res;
};
hxGeomAlgo_PolyTools.exposeEnum = function(enumClass,as) {
	var dotPath = (as != null ? as : enumClass.__ename__).split(".");
	var exports = $hx_exports;
	var i = 0;
	while(i < dotPath.length - 1) {
		var currPath = dotPath[i];
		exports[currPath] = exports[currPath] || { };
		exports = exports[currPath];
		++i;
	}
	exports[dotPath[i]] = enumClass;
};
var hxGeomAlgo_WindingRule = $hxEnums["hxGeomAlgo.WindingRule"] = { __ename__:"hxGeomAlgo.WindingRule",__constructs__:null
	,ODD: {_hx_name:"ODD",_hx_index:0,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NON_ZERO: {_hx_name:"NON_ZERO",_hx_index:1,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,POSITIVE: {_hx_name:"POSITIVE",_hx_index:2,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NEGATIVE: {_hx_name:"NEGATIVE",_hx_index:3,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,ABS_GEQ_TWO: {_hx_name:"ABS_GEQ_TWO",_hx_index:4,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
};
hxGeomAlgo_WindingRule.__constructs__ = [hxGeomAlgo_WindingRule.ODD,hxGeomAlgo_WindingRule.NON_ZERO,hxGeomAlgo_WindingRule.POSITIVE,hxGeomAlgo_WindingRule.NEGATIVE,hxGeomAlgo_WindingRule.ABS_GEQ_TWO];
var hxGeomAlgo_ResultType = $hxEnums["hxGeomAlgo.ResultType"] = { __ename__:"hxGeomAlgo.ResultType",__constructs__:null
	,POLYGONS: {_hx_name:"POLYGONS",_hx_index:0,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,CONNECTED_POLYGONS: {_hx_name:"CONNECTED_POLYGONS",_hx_index:1,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,BOUNDARY_CONTOURS: {_hx_name:"BOUNDARY_CONTOURS",_hx_index:2,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,EXPERIMENTAL_DELAUNAY: {_hx_name:"EXPERIMENTAL_DELAUNAY",_hx_index:3,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
};
hxGeomAlgo_ResultType.__constructs__ = [hxGeomAlgo_ResultType.POLYGONS,hxGeomAlgo_ResultType.CONNECTED_POLYGONS,hxGeomAlgo_ResultType.BOUNDARY_CONTOURS,hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY];
var hxGeomAlgo_Tess2 = $hx_exports["hxGeomAlgo"]["Tess2"] = function() { };
hxGeomAlgo_Tess2.__name__ = true;
hxGeomAlgo_Tess2.tesselate = function(contours,windingRule,resultType,polySize,vertexDim,normal) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var tess = new hxGeomAlgo_Tesselator();
	var _g = 0;
	var _g1 = contours.length;
	while(_g < _g1) {
		var i = _g++;
		tess.addContour(vertexDim,contours[i]);
	}
	tess.tesselate(windingRule == null ? hxGeomAlgo_WindingRule.ODD : windingRule,resultType == null ? hxGeomAlgo_ResultType.POLYGONS : resultType,polySize,vertexDim,normal == null ? [0,0,1] : normal);
	return { vertices : tess.vertices, vertexIndices : tess.vertexIndices, vertexCount : tess.vertexCount, elements : tess.elements, elementCount : tess.elementCount};
};
hxGeomAlgo_Tess2.union = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.NON_ZERO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.intersection = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.ABS_GEQ_TWO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.difference = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < contoursB.length) {
		var poly = contoursB[_g1];
		++_g1;
		_g.push(hxGeomAlgo_PolyTools.reverseFloatArray(poly));
	}
	var diffB = _g;
	var contours = contoursA.concat(diffB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.POSITIVE,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.convertResult = function(vertices,elements,resultType,polySize,out) {
	if(out == null) {
		out = [];
	}
	var tmp = resultType._hx_index != 2;
	var i = 0;
	switch(resultType._hx_index) {
	case 1:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize * 2;
		}
		break;
	case 2:
		while(i < elements.length) {
			var poly = [];
			var start = elements[i];
			var count = elements[i + 1];
			var _g = 0;
			var _g1 = count;
			while(_g < _g1) {
				var j = _g++;
				var idx = start + j;
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += 2;
		}
		break;
	case 0:case 3:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize;
		}
		break;
	}
	return out;
};
var hxGeomAlgo__$Tess2_TessVertex = function() {
	this.idx = 0;
	this.n = 0;
	this.pqHandle = 0;
	this.t = 0.0;
	this.s = 0.0;
	this.coords = [0,0,0];
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
hxGeomAlgo__$Tess2_TessVertex.__name__ = true;
var hxGeomAlgo__$Tess2_TessFace = function() {
	this.inside = false;
	this.marked = false;
	this.n = 0;
	this.trail = null;
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
hxGeomAlgo__$Tess2_TessFace.__name__ = true;
var hxGeomAlgo__$Tess2_TessHalfEdge = function(side) {
	this.winding = 0;
	this.activeRegion = null;
	this.Lface = null;
	this.Org = null;
	this.Lnext = null;
	this.Onext = null;
	this.Sym = null;
	this.next = null;
	this.side = side;
};
hxGeomAlgo__$Tess2_TessHalfEdge.__name__ = true;
hxGeomAlgo__$Tess2_TessHalfEdge.prototype = {
	get_Rface: function() {
		return this.Sym.Lface;
	}
	,set_Rface: function(v) {
		return this.Sym.Lface = v;
	}
	,get_Dst: function() {
		return this.Sym.Org;
	}
	,set_Dst: function(v) {
		return this.Sym.Org = v;
	}
	,get_Oprev: function() {
		return this.Sym.Lnext;
	}
	,get_Lprev: function() {
		return this.Onext.Sym;
	}
	,get_Rprev: function() {
		return this.Sym.Onext;
	}
	,get_Dnext: function() {
		return this.Sym.Onext.Sym;
	}
};
var hxGeomAlgo__$Tess2_TessMesh = function() {
	this.eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
	this.e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
	this.f = new hxGeomAlgo__$Tess2_TessFace();
	this.v = new hxGeomAlgo__$Tess2_TessVertex();
	this.v.next = this.v.prev = this.v;
	this.v.anEdge = null;
	this.f.next = this.f.prev = this.f;
	this.f.anEdge = null;
	this.f.trail = null;
	this.f.marked = false;
	this.f.inside = false;
	this.e.next = this.e;
	this.e.Sym = this.eSym;
	this.e.Onext = null;
	this.e.Lnext = null;
	this.e.Org = null;
	this.e.Lface = null;
	this.e.winding = 0;
	this.e.activeRegion = null;
	this.e.mark = false;
	this.eSym.next = this.eSym;
	this.eSym.Sym = this.e;
	this.eSym.Onext = null;
	this.eSym.Lnext = null;
	this.eSym.Org = null;
	this.eSym.Lface = null;
	this.eSym.winding = 0;
	this.eSym.activeRegion = null;
	this.e.Sym.mark = false;
	this.vHead = this.v;
	this.fHead = this.f;
	this.eHead = this.e;
	this.eHeadSym = this.eSym;
};
hxGeomAlgo__$Tess2_TessMesh.__name__ = true;
hxGeomAlgo__$Tess2_TessMesh.flipEdge = function(mesh,edge) {
	var a0 = edge;
	var a1 = a0.Lnext;
	var a2 = a1.Lnext;
	var b0 = edge.Sym;
	var b1 = b0.Lnext;
	var b2 = b1.Lnext;
	var aOrg = a0.Org;
	var aOpp = a2.Org;
	var bOrg = b0.Org;
	var bOpp = b2.Org;
	var fa = a0.Lface;
	var fb = b0.Lface;
	var cond = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edge);
	a0.Org = bOpp;
	a0.Onext = b1.Sym;
	b0.Org = aOpp;
	b0.Onext = a1.Sym;
	a2.Onext = b0;
	b2.Onext = a0;
	b1.Onext = a2.Sym;
	a1.Onext = b2.Sym;
	a0.Lnext = a2;
	a2.Lnext = b1;
	b1.Lnext = a0;
	b0.Lnext = b2;
	b2.Lnext = a1;
	a1.Lnext = b0;
	a1.Lface = fb;
	b1.Lface = fa;
	fa.anEdge = a0;
	fb.anEdge = b0;
	if(aOrg.anEdge == a0) {
		aOrg.anEdge = b1;
	}
	if(bOrg.anEdge == b0) {
		bOrg.anEdge = a1;
	}
	var cond = a0.get_Oprev().Onext.Org == a0.Org;
};
hxGeomAlgo__$Tess2_TessMesh.prototype = {
	makeEdge_: function(eNext) {
		var e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
		var eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
		if(eNext.Sym.side < eNext.side) {
			eNext = eNext.Sym;
		}
		var ePrev = eNext.Sym.next;
		eSym.next = ePrev;
		ePrev.Sym.next = e;
		e.next = eNext;
		eNext.Sym.next = eSym;
		e.Sym = eSym;
		e.Onext = e;
		e.Lnext = eSym;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;
		eSym.Sym = e;
		eSym.Onext = eSym;
		eSym.Lnext = e;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;
		return e;
	}
	,splice_: function(a,b) {
		var aOnext = a.Onext;
		var bOnext = b.Onext;
		aOnext.Sym.Lnext = b;
		bOnext.Sym.Lnext = a;
		a.Onext = bOnext;
		b.Onext = aOnext;
	}
	,makeVertex_: function(newVertex,eOrig,vNext) {
		var vNew = newVertex;
		var vPrev = vNext.prev;
		vNew.prev = vPrev;
		vPrev.next = vNew;
		vNew.next = vNext;
		vNext.prev = vNew;
		vNew.anEdge = eOrig;
		var e = eOrig;
		while(true) {
			e.Org = vNew;
			e = e.Onext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,makeFace_: function(newFace,eOrig,fNext) {
		var fNew = newFace;
		var fPrev = fNext.prev;
		fNew.prev = fPrev;
		fPrev.next = fNew;
		fNew.next = fNext;
		fNext.prev = fNew;
		fNew.anEdge = eOrig;
		fNew.trail = null;
		fNew.marked = false;
		fNew.inside = fNext.inside;
		var e = eOrig;
		while(true) {
			e.Lface = fNew;
			e = e.Lnext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,killEdge_: function(eDel) {
		if(eDel.Sym.side < eDel.side) {
			eDel = eDel.Sym;
		}
		var eNext = eDel.next;
		var ePrev = eDel.Sym.next;
		eNext.Sym.next = ePrev;
		ePrev.Sym.next = eNext;
	}
	,killVertex_: function(vDel,newOrg) {
		var eStart = vDel.anEdge;
		var e = eStart;
		while(true) {
			e.Org = newOrg;
			e = e.Onext;
			if(!(e != eStart)) {
				break;
			}
		}
		var vPrev = vDel.prev;
		var vNext = vDel.next;
		vNext.prev = vPrev;
		vPrev.next = vNext;
	}
	,killFace_: function(fDel,newLface) {
		var eStart = fDel.anEdge;
		var e = eStart;
		while(true) {
			e.Lface = newLface;
			e = e.Lnext;
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fDel.prev;
		var fNext = fDel.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,makeEdge: function() {
		var newVertex1 = new hxGeomAlgo__$Tess2_TessVertex();
		var newVertex2 = new hxGeomAlgo__$Tess2_TessVertex();
		var newFace = new hxGeomAlgo__$Tess2_TessFace();
		var e = this.makeEdge_(this.eHead);
		this.makeVertex_(newVertex1,e,this.vHead);
		this.makeVertex_(newVertex2,e.Sym,this.vHead);
		this.makeFace_(newFace,e,this.fHead);
		return e;
	}
	,splice: function(eOrg,eDst) {
		var joiningLoops = false;
		var joiningVertices = false;
		if(eOrg == eDst) {
			return;
		}
		if(eDst.Org != eOrg.Org) {
			joiningVertices = true;
			this.killVertex_(eDst.Org,eOrg.Org);
		}
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eDst,eOrg);
		if(!joiningVertices) {
			var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
			this.makeVertex_(newVertex,eDst,eOrg.Org);
			eOrg.Org.anEdge = eOrg;
		}
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eDst,eOrg.Lface);
			eOrg.Lface.anEdge = eOrg;
		}
	}
	,'delete': function(eDel) {
		var eDelSym = eDel.Sym;
		var joiningLoops = false;
		if(eDel.Lface != eDel.get_Rface()) {
			joiningLoops = true;
			this.killFace_(eDel.Lface,eDel.get_Rface());
		}
		if(eDel.Onext == eDel) {
			this.killVertex_(eDel.Org,null);
		} else {
			eDel.get_Rface().anEdge = eDel.get_Oprev();
			eDel.Org.anEdge = eDel.Onext;
			this.splice_(eDel,eDel.get_Oprev());
			if(!joiningLoops) {
				var newFace = new hxGeomAlgo__$Tess2_TessFace();
				this.makeFace_(newFace,eDel,eDel.Lface);
			}
		}
		if(eDelSym.Onext == eDelSym) {
			this.killVertex_(eDelSym.Org,null);
			this.killFace_(eDelSym.Lface,null);
		} else {
			eDel.Lface.anEdge = eDelSym.get_Oprev();
			eDelSym.Org.anEdge = eDelSym.Onext;
			this.splice_(eDelSym,eDelSym.get_Oprev());
		}
		this.killEdge_(eDel);
	}
	,addEdgeVertex: function(eOrg) {
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		this.splice_(eNew,eOrg.Lnext);
		eNew.Org = eOrg.get_Dst();
		var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
		this.makeVertex_(newVertex,eNewSym,eNew.Org);
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		return eNew;
	}
	,splitEdge: function(eOrg) {
		var tempHalfEdge = this.addEdgeVertex(eOrg);
		var eNew = tempHalfEdge.Sym;
		this.splice_(eOrg.Sym,eOrg.Sym.get_Oprev());
		this.splice_(eOrg.Sym,eNew);
		eOrg.set_Dst(eNew.Org);
		eNew.get_Dst().anEdge = eNew.Sym;
		eNew.set_Rface(eOrg.get_Rface());
		eNew.winding = eOrg.winding;
		eNew.Sym.winding = eOrg.Sym.winding;
		return eNew;
	}
	,connect: function(eOrg,eDst) {
		var joiningLoops = false;
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eNew,eOrg.Lnext);
		this.splice_(eNewSym,eDst);
		eNew.Org = eOrg.get_Dst();
		eNewSym.Org = eDst.Org;
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		eOrg.Lface.anEdge = eNewSym;
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eNew,eOrg.Lface);
		}
		return eNew;
	}
	,zapFace: function(fZap) {
		var eStart = fZap.anEdge;
		var e;
		var eSym;
		var eNext = eStart.Lnext;
		while(true) {
			e = eNext;
			eNext = e.Lnext;
			e.Lface = null;
			if(e.get_Rface() == null) {
				if(e.Onext == e) {
					this.killVertex_(e.Org,null);
				} else {
					e.Org.anEdge = e.Onext;
					this.splice_(e,e.get_Oprev());
				}
				eSym = e.Sym;
				if(eSym.Onext == eSym) {
					this.killVertex_(eSym.Org,null);
				} else {
					eSym.Org.anEdge = eSym.Onext;
					this.splice_(eSym,eSym.get_Oprev());
				}
				this.killEdge_(e);
			}
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fZap.prev;
		var fNext = fZap.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,countFaceVerts_: function(f) {
		var eCur = f.anEdge;
		var n = 0;
		while(true) {
			++n;
			eCur = eCur.Lnext;
			if(!(eCur != f.anEdge)) {
				break;
			}
		}
		return n;
	}
	,mergeConvexFaces: function(maxVertsPerFace) {
		var eCur;
		var eNext;
		var eSym;
		var vStart;
		var curNv;
		var symNv;
		var f = this.fHead.next;
		while(f != this.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			eCur = f.anEdge;
			vStart = eCur.Org;
			while(true) {
				eNext = eCur.Lnext;
				eSym = eCur.Sym;
				if(eSym != null && eSym.Lface != null && eSym.Lface.inside) {
					curNv = this.countFaceVerts_(f);
					symNv = this.countFaceVerts_(eSym.Lface);
					if(curNv + symNv - 2 <= maxVertsPerFace) {
						if(hxGeomAlgo__$Tess2_Geom.vertCCW(eCur.get_Lprev().Org,eCur.Org,eSym.Lnext.Lnext.Org) && hxGeomAlgo__$Tess2_Geom.vertCCW(eSym.get_Lprev().Org,eSym.Org,eCur.Lnext.Lnext.Org)) {
							eNext = eSym.Lnext;
							this.delete(eSym);
							eCur = null;
							eSym = null;
						}
					}
				}
				if(eCur != null && eCur.Lnext.Org == vStart) {
					break;
				}
				eCur = eNext;
			}
			f = f.next;
		}
		return true;
	}
	,check: function() {
		var fHead = this.fHead;
		var vHead = this.vHead;
		var eHead = this.eHead;
		var f;
		var v;
		var e;
		var fPrev = fHead;
		while(true) {
			f = fPrev.next;
			if(!(f != fHead)) {
				break;
			}
			e = f.anEdge;
			while(true) {
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			fPrev = f;
		}
		var vPrev = vHead;
		while(true) {
			v = vPrev.next;
			if(!(v != vHead)) {
				break;
			}
			e = v.anEdge;
			while(true) {
				e = e.Onext;
				if(!(e != v.anEdge)) {
					break;
				}
			}
			vPrev = v;
		}
		var ePrev = eHead;
		while(true) {
			e = ePrev.next;
			if(!(e != eHead)) {
				break;
			}
			var cond = e.get_Dst() != null;
			ePrev = e;
		}
		var cond = e.Sym.next == ePrev.Sym && e.Sym == this.eHeadSym && e.Sym.Sym == e && e.Org == null && e.get_Dst() == null && e.Lface == null && e.get_Rface() == null;
	}
};
var hxGeomAlgo__$Tess2_Geom = function() { };
hxGeomAlgo__$Tess2_Geom.__name__ = true;
hxGeomAlgo__$Tess2_Geom.vertEq = function(u,v) {
	if(u.s == v.s) {
		return u.t == v.t;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertLeq = function(u,v) {
	if(!(u.s < v.s)) {
		if(u.s == v.s) {
			return u.t <= v.t;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.transLeq = function(u,v) {
	if(!(u.t < v.t)) {
		if(u.t == v.t) {
			return u.s <= v.s;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.edgeGoesLeft = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.get_Dst(),e.Org);
};
hxGeomAlgo__$Tess2_Geom.edgeGoesRight = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
};
hxGeomAlgo__$Tess2_Geom.edgeIsInternal = function(e) {
	if(e.get_Rface() != null) {
		return e.get_Rface().inside;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertL1dist = function(u,v) {
	return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
};
hxGeomAlgo__$Tess2_Geom.edgeEval = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w);
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));
		} else {
			return v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.edgeSign = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w);
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transEval = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w);
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));
		} else {
			return v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transSign = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w);
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.vertCCW = function(u,v,w) {
	return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0.0;
};
hxGeomAlgo__$Tess2_Geom.interpolate = function(a,x,b,y) {
	if(a < 0) {
		a = 0;
	}
	if(b < 0) {
		b = 0;
	}
	if(a <= b) {
		if(b == 0) {
			return (x + y) / 2;
		} else {
			return x + (y - x) * (a / (a + b));
		}
	} else {
		return y + (x - y) * (b / (a + b));
	}
};
hxGeomAlgo__$Tess2_Geom.intersect = function(o1,d1,o2,d2,v) {
	var z1;
	var z2;
	var t;
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d1)) {
		v.s = (o2.s + d1.s) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.vertLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.edgeEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d1.s);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.edgeSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d2.s);
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d1)) {
		v.t = (o2.t + d1.t) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.transLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.transEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.transEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d1.t);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.transSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.transSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d2.t);
	}
};
hxGeomAlgo__$Tess2_Geom.calcAngle = function(v0,v1,v2) {
	var a_0 = v2.s - v1.s;
	var a_1 = v2.t - v1.t;
	var b_0 = v0.s - v1.s;
	var b_1 = v0.t - v1.t;
	var num = a_0 * b_0 + a_1 * b_1;
	var den = Math.sqrt(a_0 * a_0 + a_1 * a_1) * Math.sqrt(b_0 * b_0 + b_1 * b_1);
	if(den > 0.0) {
		num /= den;
	}
	if(num < -1.0) {
		num = -1.0;
	}
	if(num > 1.0) {
		num = 1.0;
	}
	return Math.acos(num);
};
hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay = function(e) {
	return hxGeomAlgo__$Tess2_Geom.calcAngle(e.Lnext.Org,e.Lnext.Lnext.Org,e.Org) + hxGeomAlgo__$Tess2_Geom.calcAngle(e.Sym.Lnext.Org,e.Sym.Lnext.Lnext.Org,e.Sym.Org) < Math.PI + 0.01;
};
var hxGeomAlgo__$Tess2_DictNode = function() {
	this.prev = null;
	this.next = null;
	this.key = null;
};
hxGeomAlgo__$Tess2_DictNode.__name__ = true;
var hxGeomAlgo__$Tess2_Dict = function(frame,leq) {
	this.head = new hxGeomAlgo__$Tess2_DictNode();
	this.head.next = this.head;
	this.head.prev = this.head;
	this.frame = frame;
	this.leq = leq;
};
hxGeomAlgo__$Tess2_Dict.__name__ = true;
hxGeomAlgo__$Tess2_Dict.prototype = {
	min: function() {
		return this.head.next;
	}
	,insert: function(k) {
		return this.insertBefore(this.head,k);
	}
	,search: function(key) {
		var node = this.head;
		while(true) {
			node = node.next;
			if(!(node.key != null && !this.leq(this.frame,key,node.key))) {
				break;
			}
		}
		return node;
	}
	,insertBefore: function(node,key) {
		while(true) {
			node = node.prev;
			if(!(node.key != null && !this.leq(this.frame,node.key,key))) {
				break;
			}
		}
		var newNode = new hxGeomAlgo__$Tess2_DictNode();
		newNode.key = key;
		newNode.next = node.next;
		node.next.prev = newNode;
		newNode.prev = node;
		node.next = newNode;
		return newNode;
	}
	,'delete': function(node) {
		node.next.prev = node.prev;
		node.prev.next = node.next;
	}
};
var hxGeomAlgo__$Tess2_PQNode = function() {
	this.handle = -1;
};
hxGeomAlgo__$Tess2_PQNode.__name__ = true;
var hxGeomAlgo__$Tess2_PQHandleElem = function() {
	this.node = -1;
	this.key = null;
};
hxGeomAlgo__$Tess2_PQHandleElem.__name__ = true;
var hxGeomAlgo__$Tess2_PriorityQ = function(size,leq) {
	this.size = 0;
	this.max = size;
	this.nodes = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
	}
	this.handles = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.handles[i] = new hxGeomAlgo__$Tess2_PQHandleElem();
	}
	this.initialized = false;
	this.freeList = 0;
	this.leq = leq;
	this.nodes[1].handle = 1;
	this.handles[1].key = null;
};
hxGeomAlgo__$Tess2_PriorityQ.__name__ = true;
hxGeomAlgo__$Tess2_PriorityQ.prototype = {
	floatDown_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hChild;
		var child;
		var hCurr = n[curr].handle;
		while(true) {
			child = curr << 1;
			if(child < this.size && this.leq(h[n[child + 1].handle].key,h[n[child].handle].key)) {
				++child;
			}
			hChild = n[child].handle;
			if(child > this.size || this.leq(h[hCurr].key,h[hChild].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hChild;
			h[hChild].node = curr;
			curr = child;
		}
	}
	,floatUp_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hParent;
		var parent;
		var hCurr = n[curr].handle;
		while(true) {
			parent = curr >> 1;
			hParent = n[parent].handle;
			if(parent == 0 || this.leq(h[hParent].key,h[hCurr].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hParent;
			h[hParent].node = curr;
			curr = parent;
		}
	}
	,init: function() {
		var i = this.size;
		while(i >= 1) {
			this.floatDown_(i);
			--i;
		}
		this.initialized = true;
	}
	,min: function() {
		return this.handles[this.nodes[1].handle].key;
	}
	,insert: function(keyNew) {
		var free;
		var curr = ++this.size;
		if(curr * 2 > this.max) {
			this.max *= 2;
			var s = this.nodes.length;
			var _g = s;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
			}
			s = this.handles.length;
			var _g = this.handles.length;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.handles[i] = new hxGeomAlgo__$Tess2_PQHandleElem();
			}
		}
		if(this.freeList == 0) {
			free = curr;
		} else {
			free = this.freeList;
			this.freeList = this.handles[free].node;
		}
		this.nodes[curr].handle = free;
		this.handles[free].node = curr;
		this.handles[free].key = keyNew;
		if(this.initialized) {
			this.floatUp_(curr);
		}
		return free;
	}
	,extractMin: function() {
		var n = this.nodes;
		var h = this.handles;
		var hMin = n[1].handle;
		var min = h[hMin].key;
		if(this.size > 0) {
			n[1].handle = n[this.size].handle;
			h[n[1].handle].node = 1;
			h[hMin].key = null;
			h[hMin].node = this.freeList;
			this.freeList = hMin;
			--this.size;
			if(this.size > 0) {
				this.floatDown_(1);
			}
		}
		return min;
	}
	,'delete': function(hCurr) {
		var n = this.nodes;
		var h = this.handles;
		var curr = h[hCurr].node;
		n[curr].handle = n[this.size].handle;
		h[n[curr].handle].node = curr;
		--this.size;
		if(curr <= this.size) {
			if(curr <= 1 || this.leq(h[n[curr >> 1].handle].key,h[n[curr].handle].key)) {
				this.floatDown_(curr);
			} else {
				this.floatUp_(curr);
			}
		}
		h[hCurr].key = null;
		h[hCurr].node = this.freeList;
		this.freeList = hCurr;
	}
};
var hxGeomAlgo__$Tess2_ActiveRegion = function() {
	this.fixUpperEdge = false;
	this.dirty = false;
	this.sentinel = false;
	this.inside = false;
	this.windingNumber = 0;
	this.nodeUp = null;
	this.eUp = null;
};
hxGeomAlgo__$Tess2_ActiveRegion.__name__ = true;
var hxGeomAlgo__$Tess2_Sweep = function() { };
hxGeomAlgo__$Tess2_Sweep.__name__ = true;
hxGeomAlgo__$Tess2_Sweep.regionBelow = function(r) {
	return r.nodeUp.prev.key;
};
hxGeomAlgo__$Tess2_Sweep.regionAbove = function(r) {
	return r.nodeUp.next.key;
};
hxGeomAlgo__$Tess2_Sweep.debugEvent = function(tess) {
};
hxGeomAlgo__$Tess2_Sweep.addWinding = function(eDst,eSrc) {
	eDst.winding += eSrc.winding;
	eDst.Sym.winding += eSrc.Sym.winding;
};
hxGeomAlgo__$Tess2_Sweep.edgeLeq = function(tess,reg1,reg2) {
	var ev = tess.event;
	var t1;
	var t2;
	var e1 = reg1.eUp;
	var e2 = reg2.eUp;
	if(e1.get_Dst() == ev) {
		if(e2.get_Dst() == ev) {
			if(hxGeomAlgo__$Tess2_Geom.vertLeq(e1.Org,e2.Org)) {
				return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),e1.Org,e2.Org) <= 0;
			}
			return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),e2.Org,e1.Org) >= 0;
		}
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),ev,e2.Org) <= 0;
	}
	if(e2.get_Dst() == ev) {
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),ev,e1.Org) >= 0;
	}
	var t1 = hxGeomAlgo__$Tess2_Geom.edgeEval(e1.get_Dst(),ev,e1.Org);
	var t2 = hxGeomAlgo__$Tess2_Geom.edgeEval(e2.get_Dst(),ev,e2.Org);
	return t1 >= t2;
};
hxGeomAlgo__$Tess2_Sweep.deleteRegion = function(tess,reg) {
	var reg1 = reg.fixUpperEdge;
	reg.eUp.activeRegion = null;
	tess.dict.delete(reg.nodeUp);
};
hxGeomAlgo__$Tess2_Sweep.fixUpperEdge = function(tess,reg,newEdge) {
	tess.mesh.delete(reg.eUp);
	reg.fixUpperEdge = false;
	reg.eUp = newEdge;
	newEdge.activeRegion = reg;
};
hxGeomAlgo__$Tess2_Sweep.topLeftRegion = function(tess,reg) {
	var org = reg.eUp.Org;
	var e;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.Org == org)) {
			break;
		}
	}
	if(reg.fixUpperEdge) {
		e = tess.mesh.connect(hxGeomAlgo__$Tess2_Sweep.regionBelow(reg).eUp.Sym,reg.eUp.Lnext);
		if(e == null) {
			return null;
		}
		hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.topRightRegion = function(reg) {
	var dst = reg.eUp.get_Dst();
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.get_Dst() == dst)) {
			break;
		}
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.addRegionBelow = function(tess,regAbove,eNewUp) {
	var regNew = new hxGeomAlgo__$Tess2_ActiveRegion();
	regNew.eUp = eNewUp;
	regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp,regNew);
	regNew.fixUpperEdge = false;
	regNew.sentinel = false;
	regNew.dirty = false;
	eNewUp.activeRegion = regNew;
	return regNew;
};
hxGeomAlgo__$Tess2_Sweep.isWindingInside = function(tess,n) {
	switch(tess.windingRule._hx_index) {
	case 0:
		return (n & 1) != 0;
	case 1:
		return n != 0;
	case 2:
		return n > 0;
	case 3:
		return n < 0;
	case 4:
		if(n < 2) {
			return n <= -2;
		} else {
			return true;
		}
		break;
	}
};
hxGeomAlgo__$Tess2_Sweep.computeWinding = function(tess,reg) {
	reg.windingNumber = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
	reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
};
hxGeomAlgo__$Tess2_Sweep.finishRegion = function(tess,reg) {
	var e = reg.eUp;
	var f = e.Lface;
	f.inside = reg.inside;
	f.anEdge = e;
	hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
};
hxGeomAlgo__$Tess2_Sweep.finishLeftRegions = function(tess,regFirst,regLast) {
	var e;
	var ePrev;
	var reg = null;
	var regPrev = regFirst;
	var ePrev = regFirst.eUp;
	while(regPrev != regLast) {
		regPrev.fixUpperEdge = false;
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp;
		if(e.Org != ePrev.Org) {
			if(!reg.fixUpperEdge) {
				hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
				break;
			}
			e = tess.mesh.connect(ePrev.get_Lprev(),e.Sym);
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		}
		if(ePrev.Onext != e) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev,e);
		}
		hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
		ePrev = reg.eUp;
		regPrev = reg;
	}
	return ePrev;
};
hxGeomAlgo__$Tess2_Sweep.addRightEdges = function(tess,regUp,eFirst,eLast,eTopLeft,cleanUp) {
	var reg = null;
	var firstTime = true;
	var e = eFirst;
	while(true) {
		var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
		hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,e.Sym);
		e = e.Onext;
		if(!(e != eLast)) {
			break;
		}
	}
	if(eTopLeft == null) {
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
	}
	var regPrev = regUp;
	var ePrev = eTopLeft;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp.Sym;
		if(e.Org != ePrev.Org) {
			break;
		}
		if(e.Onext != ePrev) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev.get_Oprev(),e);
		}
		reg.windingNumber = regPrev.windingNumber - e.winding;
		reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
		regPrev.dirty = true;
		if(!firstTime && hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regPrev)) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e,ePrev);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regPrev);
			tess.mesh.delete(ePrev);
		}
		firstTime = false;
		regPrev = reg;
		ePrev = e;
	}
	regPrev.dirty = true;
	if(cleanUp) {
		hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regPrev);
	}
};
hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices = function(tess,e1,e2) {
	tess.mesh.splice(e1,e2);
};
hxGeomAlgo__$Tess2_Sweep.vertexWeights = function(isect,org,dst) {
	var t1 = hxGeomAlgo__$Tess2_Geom.vertL1dist(org,isect);
	var t2 = hxGeomAlgo__$Tess2_Geom.vertL1dist(dst,isect);
	var w0 = 0.5 * t2 / (t1 + t2);
	var w1 = 0.5 * t1 / (t1 + t2);
	isect.coords[0] += w0 * org.coords[0] + w1 * dst.coords[0];
	isect.coords[1] += w0 * org.coords[1] + w1 * dst.coords[1];
	isect.coords[2] += w0 * org.coords[2] + w1 * dst.coords[2];
};
hxGeomAlgo__$Tess2_Sweep.getIntersectData = function(tess,isect,orgUp,dstUp,orgLo,dstLo) {
	var tmp = isect.coords[1] = isect.coords[2] = 0;
	isect.coords[0] = tmp;
	isect.idx = -1;
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgUp,dstUp);
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgLo,dstLo);
};
hxGeomAlgo__$Tess2_Sweep.checkForRightSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.Org,eLo.Org)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.Org,eLo.Org) > 0) {
			return false;
		}
		if(!hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,eLo.Org)) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp,eLo.get_Oprev());
			regUp.dirty = regLo.dirty = true;
		} else if(eUp.Org != eLo.Org) {
			tess.pq.delete(eUp.Org.pqHandle);
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLo.get_Oprev(),eUp);
		}
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.Org,eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		tess.mesh.splitEdge(eUp.Sym);
		tess.mesh.splice(eLo.get_Oprev(),eUp);
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var e;
	var cond = !hxGeomAlgo__$Tess2_Geom.vertEq(eUp.get_Dst(),eLo.get_Dst());
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.get_Dst(),eLo.get_Dst())) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.get_Dst(),eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		e = tess.mesh.splitEdge(eUp);
		tess.mesh.splice(eLo.Sym,e);
		e.Lface.inside = regUp.inside;
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.get_Dst(),eLo.Org) > 0) {
			return false;
		}
		regUp.dirty = regLo.dirty = true;
		e = tess.mesh.splitEdge(eLo);
		tess.mesh.splice(eUp.Lnext,eLo.Sym);
		e.get_Rface().inside = regUp.inside;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForIntersect = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var orgUp = eUp.Org;
	var orgLo = eLo.Org;
	var dstUp = eUp.get_Dst();
	var dstLo = eLo.get_Dst();
	var isect = new hxGeomAlgo__$Tess2_TessVertex();
	var e;
	var cond = !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,dstUp);
	var cond = hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,orgUp) <= 0;
	var cond = hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,orgLo) >= 0;
	if(orgUp == orgLo) {
		return false;
	}
	var tMinUp = Math.min(orgUp.t,dstUp.t);
	var tMaxLo = Math.max(orgLo.t,dstLo.t);
	if(tMinUp > tMaxLo) {
		return false;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,orgUp,orgLo) > 0) {
			return false;
		}
	} else if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,orgLo,orgUp) < 0) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Geom.intersect(dstUp,orgUp,dstLo,orgLo,isect);
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(isect,tess.event)) {
		isect.s = tess.event.s;
		isect.t = tess.event.t;
	}
	var orgMin = hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo) ? orgUp : orgLo;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgMin,isect)) {
		isect.s = orgMin.s;
		isect.t = orgMin.t;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgUp) || hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgLo)) {
		hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
		return false;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(dstUp,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0 || !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
		if(dstLo == tess.event) {
			tess.mesh.splitEdge(eUp.Sym);
			tess.mesh.splice(eLo.Sym,eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
			eUp = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
			hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eUp.get_Oprev(),eUp,eUp,true);
			return true;
		}
		if(dstUp == tess.event) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp.Lnext,eLo.get_Oprev());
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
			e = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
			regLo.eUp = eLo.get_Oprev();
			eLo = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eLo.Onext,eUp.get_Rprev(),e,true);
			return true;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0) {
			hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge(eUp.Sym);
			eUp.Org.s = tess.event.s;
			eUp.Org.t = tess.event.t;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
			regUp.dirty = regLo.dirty = true;
			tess.mesh.splitEdge(eLo.Sym);
			eLo.Org.s = tess.event.s;
			eLo.Org.t = tess.event.t;
		}
		return false;
	}
	tess.mesh.splitEdge(eUp.Sym);
	tess.mesh.splitEdge(eLo.Sym);
	tess.mesh.splice(eLo.get_Oprev(),eUp);
	eUp.Org.s = isect.s;
	eUp.Org.t = isect.t;
	eUp.Org.pqHandle = tess.pq.insert(eUp.Org);
	hxGeomAlgo__$Tess2_Sweep.getIntersectData(tess,eUp.Org,orgUp,dstUp,orgLo,dstLo);
	hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
	return false;
};
hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp;
	var eLo;
	while(true) {
		while(regLo.dirty) {
			regUp = regLo;
			regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regLo);
		}
		if(!regUp.dirty) {
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp);
			if(regUp == null || !regUp.dirty) {
				return;
			}
		}
		regUp.dirty = false;
		eUp = regUp.eUp;
		eLo = regLo.eUp;
		if(eUp.get_Dst() != eLo.get_Dst()) {
			if(hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice(tess,regUp)) {
				if(regLo.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regLo);
					tess.mesh.delete(eLo);
					regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
					eLo = regLo.eUp;
				} else if(regUp.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
					tess.mesh.delete(eUp);
					regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
					eUp = regUp.eUp;
				}
			}
		}
		if(eUp.Org != eLo.Org) {
			if(eUp.get_Dst() != eLo.get_Dst() && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.get_Dst() == tess.event || eLo.get_Dst() == tess.event)) {
				if(hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp)) {
					return;
				}
			} else {
				hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
			}
		}
		if(eUp.Org == eLo.Org && eUp.get_Dst() == eLo.get_Dst()) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(eLo,eUp);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
			tess.mesh.delete(eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
		}
	}
};
hxGeomAlgo__$Tess2_Sweep.connectRightVertex = function(tess,regUp,eBottomLeft) {
	var eNew;
	var eTopLeft = eBottomLeft.Onext;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var degenerate = false;
	if(eUp.get_Dst() != eLo.get_Dst()) {
		hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp);
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,tess.event)) {
		tess.mesh.splice(eTopLeft.get_Oprev(),eUp);
		regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
		hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
		degenerate = true;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eLo.Org,tess.event)) {
		tess.mesh.splice(eBottomLeft,eLo.get_Oprev());
		eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
		degenerate = true;
	}
	if(degenerate) {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
		return;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.Org,eUp.Org)) {
		eNew = eLo.get_Oprev();
	} else {
		eNew = eUp;
	}
	eNew = tess.mesh.connect(eBottomLeft.get_Lprev(),eNew);
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eNew,eNew.Onext,eNew.Onext,false);
	eNew.Sym.activeRegion.fixUpperEdge = true;
	hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regUp);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate = function(tess,regUp,vEvent) {
	var e = regUp.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,vEvent)) {
		hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,e,vEvent.anEdge);
		return;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(e.get_Dst(),vEvent)) {
		tess.mesh.splitEdge(e.Sym);
		if(regUp.fixUpperEdge) {
			tess.mesh.delete(e.Onext);
			regUp.fixUpperEdge = false;
		}
		tess.mesh.splice(vEvent.anEdge,e);
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
		return;
	}
	regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopRight = reg.eUp.Sym;
	var eLast = eTopRight.Onext;
	var eTopLeft = eLast;
	if(reg.fixUpperEdge) {
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
		tess.mesh.delete(eTopRight);
		eTopRight = eTopLeft.get_Oprev();
	}
	tess.mesh.splice(vEvent.anEdge,eTopRight);
	if(!hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(eTopLeft)) {
		eTopLeft = null;
	}
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eTopRight.Onext,eLast,eTopLeft,true);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftVertex = function(tess,vEvent) {
	var eNew;
	var tmp = new hxGeomAlgo__$Tess2_ActiveRegion();
	tmp.eUp = vEvent.anEdge.Sym;
	var regUp = tess.dict.search(tmp).key;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	if(regLo == null) {
		return;
	}
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),vEvent,eUp.Org) == 0.0) {
		hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate(tess,regUp,vEvent);
		return;
	}
	var reg = hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.get_Dst(),eUp.get_Dst()) ? regUp : regLo;
	if(regUp.inside || reg.fixUpperEdge) {
		if(reg == regUp) {
			eNew = tess.mesh.connect(vEvent.anEdge.Sym,eUp.Lnext);
		} else {
			var tempHalfEdge = tess.mesh.connect(eLo.get_Dnext(),vEvent.anEdge);
			eNew = tempHalfEdge.Sym;
		}
		if(reg.fixUpperEdge) {
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,eNew);
		} else {
			hxGeomAlgo__$Tess2_Sweep.computeWinding(tess,hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,eNew));
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,vEvent.anEdge,vEvent.anEdge,null,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.sweepEvent = function(tess,vEvent) {
	tess.event = vEvent;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	var e = vEvent.anEdge;
	while(e.activeRegion == null) {
		e = e.Onext;
		if(e == vEvent.anEdge) {
			hxGeomAlgo__$Tess2_Sweep.connectLeftVertex(tess,vEvent);
			return;
		}
	}
	var regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,e.activeRegion);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopLeft = reg.eUp;
	var eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,reg,null);
	if(eBottomLeft.Onext == eTopLeft) {
		hxGeomAlgo__$Tess2_Sweep.connectRightVertex(tess,regUp,eBottomLeft);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.addSentinel = function(tess,smin,smax,t) {
	var reg = new hxGeomAlgo__$Tess2_ActiveRegion();
	var e = tess.mesh.makeEdge();
	e.Org.s = smax;
	e.Org.t = t;
	e.get_Dst().s = smin;
	e.get_Dst().t = t;
	tess.event = e.get_Dst();
	reg.eUp = e;
	reg.windingNumber = 0;
	reg.inside = false;
	reg.fixUpperEdge = false;
	reg.sentinel = true;
	reg.dirty = false;
	reg.nodeUp = tess.dict.insert(reg);
};
hxGeomAlgo__$Tess2_Sweep.initEdgeDict = function(tess) {
	tess.dict = new hxGeomAlgo__$Tess2_Dict(tess,hxGeomAlgo__$Tess2_Sweep.edgeLeq);
	var w = tess.bmax[0] - tess.bmin[0];
	var h = tess.bmax[1] - tess.bmin[1];
	var smin = tess.bmin[0] - w;
	var smax = tess.bmax[0] + w;
	var tmin = tess.bmin[1] - h;
	var tmax = tess.bmax[1] + h;
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmin);
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmax);
};
hxGeomAlgo__$Tess2_Sweep.doneEdgeDict = function(tess) {
	var reg;
	var fixedEdges = 0;
	while(true) {
		reg = tess.dict.min().key;
		if(!(reg != null)) {
			break;
		}
		if(!reg.sentinel) {
			var cond = ++fixedEdges == 1;
		}
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
	}
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges = function(tess) {
	var eNext;
	var eLnext;
	var eHead = tess.mesh.eHead;
	var e = eHead.next;
	while(e != eHead) {
		eNext = e.next;
		eLnext = e.Lnext;
		if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,e.get_Dst()) && e.Lnext.Lnext != e) {
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLnext,e);
			tess.mesh.delete(e);
			e = eLnext;
			eLnext = e.Lnext;
		}
		if(eLnext.Lnext == e) {
			if(eLnext != e) {
				if(eLnext == eNext || eLnext == eNext.Sym) {
					eNext = eNext.next;
				}
				tess.mesh.delete(eLnext);
			}
			if(e == eNext || e == eNext.Sym) {
				eNext = eNext.next;
			}
			tess.mesh.delete(e);
		}
		e = eNext;
	}
};
hxGeomAlgo__$Tess2_Sweep.initPriorityQ = function(tess) {
	var vertexCount = 0;
	var vHead = tess.mesh.vHead;
	var v = vHead.next;
	while(v != vHead) {
		++vertexCount;
		v = v.next;
	}
	vertexCount += 8;
	var pq = tess.pq = new hxGeomAlgo__$Tess2_PriorityQ(vertexCount,hxGeomAlgo__$Tess2_Geom.vertLeq);
	vHead = tess.mesh.vHead;
	v = vHead.next;
	while(v != vHead) {
		v.pqHandle = pq.insert(v);
		v = v.next;
	}
	if(v != vHead) {
		return false;
	}
	pq.init();
	return true;
};
hxGeomAlgo__$Tess2_Sweep.donePriorityQ = function(tess) {
	tess.pq = null;
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces = function(tess,mesh) {
	var fNext;
	var e;
	var f = mesh.fHead.next;
	while(f != mesh.fHead) {
		fNext = f.next;
		e = f.anEdge;
		if(e.Lnext.Lnext == e) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e.Onext,e);
			tess.mesh.delete(e);
		}
		f = fNext;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.computeInterior = function(tess) {
	var v;
	var vNext;
	hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.initPriorityQ(tess)) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.initEdgeDict(tess);
	var pq = tess.pq;
	while(true) {
		v = tess.pq.extractMin();
		if(!(v != null)) {
			break;
		}
		while(true) {
			vNext = tess.pq.min();
			if(vNext == null || !hxGeomAlgo__$Tess2_Geom.vertEq(vNext,v)) {
				break;
			}
			vNext = tess.pq.extractMin();
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,v.anEdge,vNext.anEdge);
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,v);
	}
	tess.event = tess.dict.min().key.eUp.Org;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Sweep.doneEdgeDict(tess);
	hxGeomAlgo__$Tess2_Sweep.donePriorityQ(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces(tess,tess.mesh)) {
		return false;
	}
	tess.mesh.check();
	return true;
};
var hxGeomAlgo_Tesselator = $hx_exports["hxGeomAlgo"]["Tesselator"] = function() {
	this.elementCount = 0;
	this.elements = [];
	this.vertexCount = 0;
	this.vertexIndices = [];
	this.vertices = [];
	this.vertexIndexCounter = 0;
	this.event = null;
	this.pq = null;
	this.dict = null;
	this.bmax = [0.0,0.0];
	this.bmin = [0.0,0.0];
	this.tUnit = [0.0,0.0,0.0];
	this.sUnit = [0.0,0.0,0.0];
	this.normal = [0.0,0.0,0.0];
	this.mesh = null;
	this.windingRule = hxGeomAlgo_WindingRule.ODD;
};
hxGeomAlgo_Tesselator.__name__ = true;
hxGeomAlgo_Tesselator.prototype = {
	dot_: function(u,v) {
		return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
	}
	,normalize_: function(v) {
		var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
		len = Math.sqrt(len);
		v[0] /= len;
		v[1] /= len;
		v[2] /= len;
	}
	,longAxis_: function(v) {
		var i = 0;
		if(Math.abs(v[1]) > Math.abs(v[0])) {
			i = 1;
		}
		if(Math.abs(v[2]) > Math.abs(v[i])) {
			i = 2;
		}
		return i;
	}
	,computeNormal_: function(norm) {
		var c;
		var tLen2;
		var maxVal = [.0,.0,.0];
		var minVal = [.0,.0,.0];
		var d1 = [.0,.0,.0];
		var d2_0 = .0;
		var d2_1 = .0;
		var d2_2 = .0;
		var tNorm_0 = .0;
		var tNorm_1 = .0;
		var tNorm_2 = .0;
		var maxVert = [null,null,null];
		var minVert = [null,null,null];
		var vHead = this.mesh.vHead;
		var v = vHead.next;
		c = v.coords[0];
		minVal[0] = c;
		minVert[0] = v;
		maxVal[0] = c;
		maxVert[0] = v;
		c = v.coords[1];
		minVal[1] = c;
		minVert[1] = v;
		maxVal[1] = c;
		maxVert[1] = v;
		c = v.coords[2];
		minVal[2] = c;
		minVert[2] = v;
		maxVal[2] = c;
		maxVert[2] = v;
		v = vHead.next;
		while(v != vHead) {
			c = v.coords[0];
			if(c < minVal[0]) {
				minVal[0] = c;
				minVert[0] = v;
			}
			if(c > maxVal[0]) {
				maxVal[0] = c;
				maxVert[0] = v;
			}
			c = v.coords[1];
			if(c < minVal[1]) {
				minVal[1] = c;
				minVert[1] = v;
			}
			if(c > maxVal[1]) {
				maxVal[1] = c;
				maxVert[1] = v;
			}
			c = v.coords[2];
			if(c < minVal[2]) {
				minVal[2] = c;
				minVert[2] = v;
			}
			if(c > maxVal[2]) {
				maxVal[2] = c;
				maxVert[2] = v;
			}
			v = v.next;
		}
		var i = 0;
		if(maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
			i = 1;
		}
		if(maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
			i = 2;
		}
		if(minVal[i] >= maxVal[i]) {
			norm[0] = 0;
			norm[1] = 0;
			norm[2] = 1;
			return;
		}
		var maxLen2 = .0;
		var v1 = minVert[i];
		var v2 = maxVert[i];
		d1[0] = v1.coords[0] - v2.coords[0];
		d1[1] = v1.coords[1] - v2.coords[1];
		d1[2] = v1.coords[2] - v2.coords[2];
		v = vHead.next;
		while(v != vHead) {
			d2_0 = v.coords[0] - v2.coords[0];
			d2_1 = v.coords[1] - v2.coords[1];
			d2_2 = v.coords[2] - v2.coords[2];
			tNorm_0 = d1[1] * d2_2 - d1[2] * d2_1;
			tNorm_1 = d1[2] * d2_0 - d1[0] * d2_2;
			tNorm_2 = d1[0] * d2_1 - d1[1] * d2_0;
			tLen2 = tNorm_0 * tNorm_0 + tNorm_1 * tNorm_1 + tNorm_2 * tNorm_2;
			if(tLen2 > maxLen2) {
				maxLen2 = tLen2;
				norm[0] = tNorm_0;
				norm[1] = tNorm_1;
				norm[2] = tNorm_2;
			}
			v = v.next;
		}
		if(maxLen2 <= 0) {
			norm[0] = norm[1] = norm[2] = 0;
			norm[this.longAxis_(d1)] = 1;
		}
	}
	,checkOrientation_: function() {
		var fHead = this.mesh.fHead;
		var v;
		var vHead = this.mesh.vHead;
		var e;
		var area = .0;
		var f = fHead.next;
		while(f != fHead) {
			e = f.anEdge;
			if(e.winding <= 0) {
				f = f.next;
				continue;
			}
			while(true) {
				area += (e.Org.s - e.get_Dst().s) * (e.Org.t + e.get_Dst().t);
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			f = f.next;
		}
		if(area < 0) {
			v = vHead.next;
			while(v != vHead) {
				v.t = -v.t;
				v = v.next;
			}
			this.tUnit[0] = -this.tUnit[0];
			this.tUnit[1] = -this.tUnit[1];
			this.tUnit[2] = -this.tUnit[2];
		}
	}
	,projectPolygon_: function() {
		var vHead = this.mesh.vHead;
		var norm = [.0,.0,.0];
		var computedNormal = false;
		norm[0] = this.normal[0];
		norm[1] = this.normal[1];
		norm[2] = this.normal[2];
		if(norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 0.0) {
			this.computeNormal_(norm);
			computedNormal = true;
		}
		var sUnit = this.sUnit;
		var tUnit = this.tUnit;
		var i = this.longAxis_(norm);
		sUnit[i] = 0;
		sUnit[(i + 1) % 3] = 1.0;
		sUnit[(i + 2) % 3] = 0.0;
		tUnit[i] = 0;
		tUnit[(i + 1) % 3] = 0.0;
		tUnit[(i + 2) % 3] = norm[i] > 0 ? 1.0 : -1.0;
		var v = vHead.next;
		while(v != vHead) {
			v.s = this.dot_(v.coords,sUnit);
			v.t = this.dot_(v.coords,tUnit);
			v = v.next;
		}
		if(computedNormal) {
			this.checkOrientation_();
		}
		var first = true;
		v = vHead.next;
		while(v != vHead) {
			if(first) {
				var tmp = this.bmax[0] = v.s;
				this.bmin[0] = tmp;
				var tmp1 = this.bmax[1] = v.t;
				this.bmin[1] = tmp1;
				first = false;
			} else {
				if(v.s < this.bmin[0]) {
					this.bmin[0] = v.s;
				}
				if(v.s > this.bmax[0]) {
					this.bmax[0] = v.s;
				}
				if(v.t < this.bmin[1]) {
					this.bmin[1] = v.t;
				}
				if(v.t > this.bmax[1]) {
					this.bmax[1] = v.t;
				}
			}
			v = v.next;
		}
	}
	,addWinding_: function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}
	,tessellateMonoRegion_: function(mesh,face) {
		var up = face.anEdge;
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),up.Org)) up = up.get_Lprev();
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.Org,up.get_Dst())) up = up.Lnext;
		var lo = up.get_Lprev();
		while(up.Lnext != lo) if(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),lo.Org)) {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(lo.Lnext) || hxGeomAlgo__$Tess2_Geom.edgeSign(lo.Org,lo.get_Dst(),lo.Lnext.get_Dst()) <= 0.0)) {
				var tempHalfEdge = mesh.connect(lo.Lnext,lo);
				lo = tempHalfEdge.Sym;
			}
			lo = lo.get_Lprev();
		} else {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesRight(up.get_Lprev()) || hxGeomAlgo__$Tess2_Geom.edgeSign(up.get_Dst(),up.Org,up.get_Lprev().Org) >= 0.0)) {
				var tempHalfEdge1 = mesh.connect(up,up.get_Lprev());
				up = tempHalfEdge1.Sym;
			}
			up = up.Lnext;
		}
		while(lo.Lnext.Lnext != up) {
			var tempHalfEdge = mesh.connect(lo.Lnext,lo);
			lo = tempHalfEdge.Sym;
		}
		return true;
	}
	,tessellateInterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(f.inside) {
				if(!this.tessellateMonoRegion_(mesh,f)) {
					return false;
				}
			}
			f = next;
		}
		return true;
	}
	,refineDelaunay_: function(mesh) {
		var stack = [];
		var e;
		var edges_0 = null;
		var edges_1 = null;
		var edges_2 = null;
		var edges_3 = null;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(f.inside) {
				e = f.anEdge;
				while(true) {
					e.mark = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(e);
					if(e.mark && !e.Sym.mark) {
						stack.push(e);
					}
					e = e.Lnext;
					if(!(e != f.anEdge)) {
						break;
					}
				}
			}
			f = f.next;
		}
		while(stack.length > 0) {
			e = stack.pop();
			e.mark = e.Sym.mark = false;
			if(!hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay(e)) {
				hxGeomAlgo__$Tess2_TessMesh.flipEdge(mesh,e);
				edges_0 = e.Lnext;
				edges_1 = e.get_Lprev();
				edges_2 = e.Sym.Lnext;
				edges_3 = e.Sym.get_Lprev();
				if(!edges_0.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_0)) {
					edges_0.mark = edges_0.Sym.mark = true;
					stack.push(edges_0);
				}
				if(!edges_1.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_1)) {
					edges_1.mark = edges_1.Sym.mark = true;
					stack.push(edges_1);
				}
				if(!edges_2.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_2)) {
					edges_2.mark = edges_2.Sym.mark = true;
					stack.push(edges_2);
				}
			}
		}
		var _g = 0;
		while(_g < stack.length) {
			var e = stack[_g];
			++_g;
			stack.pop();
		}
		stack = null;
	}
	,discardExterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(!f.inside) {
				mesh.zapFace(f);
			}
			f = next;
		}
	}
	,setWindingNumber_: function(mesh,value,keepOnlyBoundary) {
		var eNext;
		var e = mesh.eHead.next;
		while(e != mesh.eHead) {
			eNext = e.next;
			if(e.get_Rface().inside != e.Lface.inside) {
				e.winding = e.Lface.inside ? value : -value;
			} else if(!keepOnlyBoundary) {
				e.winding = 0;
			} else {
				mesh.delete(e);
			}
			e = eNext;
		}
	}
	,getNeighbourFace_: function(edge) {
		if(edge.get_Rface() == null) {
			return -1;
		}
		if(!edge.get_Rface().inside) {
			return -1;
		}
		return edge.get_Rface().n;
	}
	,outputPolymesh_: function(mesh,resultsType,polySize,vertexDim) {
		var edge;
		var maxFaceCount = 0;
		var maxVertexCount = 0;
		var faceVerts;
		var i;
		var elements = 0;
		var vert;
		if(polySize > 3) {
			mesh.mergeConvexFaces(polySize);
		}
		var v = mesh.vHead.next;
		while(v != mesh.vHead) {
			v.n = -1;
			v = v.next;
		}
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			f.n = -1;
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				if(v.n == -1) {
					v.n = maxVertexCount;
					++maxVertexCount;
				}
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			f.n = maxFaceCount;
			++maxFaceCount;
			f = f.next;
		}
		this.elementCount = maxFaceCount;
		if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
			maxFaceCount *= 2;
		}
		this.elements = [];
		this.vertexCount = maxVertexCount;
		this.vertices = [];
		this.vertexIndices = [];
		v = mesh.vHead.next;
		while(v != mesh.vHead) {
			if(v.n != -1) {
				var idx = v.n * vertexDim;
				this.vertices[idx] = v.coords[0];
				this.vertices[idx + 1] = v.coords[1];
				if(vertexDim > 2) {
					this.vertices[idx + 2] = v.coords[2];
				}
				this.vertexIndices[v.n] = v.idx;
			}
			v = v.next;
		}
		var nel = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				this.elements[nel++] = v.n;
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			var _g = faceVerts;
			var _g1 = polySize;
			while(_g < _g1) {
				var i = _g++;
				this.elements[nel++] = -1;
			}
			if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
				edge = f.anEdge;
				while(true) {
					this.elements[nel++] = this.getNeighbourFace_(edge);
					edge = edge.Lnext;
					if(!(edge != f.anEdge)) {
						break;
					}
				}
				var _g2 = faceVerts;
				var _g3 = polySize;
				while(_g2 < _g3) {
					var i1 = _g2++;
					this.elements[nel++] = -1;
				}
			}
			f = f.next;
		}
	}
	,outputContours_: function(mesh,vertexDim) {
		var edge;
		var start;
		var verts;
		var elements;
		var vertInds;
		var startVert = 0;
		var vertCount = 0;
		this.vertexCount = 0;
		this.elementCount = 0;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertexCount++;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elementCount++;
			f = f.next;
		}
		this.elements = [];
		this.vertices = [];
		this.vertexIndices = [];
		var nv = 0;
		var nvi = 0;
		var nel = 0;
		startVert = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			vertCount = 0;
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertices[nv++] = edge.Org.coords[0];
				this.vertices[nv++] = edge.Org.coords[1];
				if(vertexDim > 2) {
					this.vertices[nv++] = edge.Org.coords[2];
				}
				this.vertexIndices[nvi++] = edge.Org.idx;
				++vertCount;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elements[nel++] = startVert;
			this.elements[nel++] = vertCount;
			startVert += vertCount;
			f = f.next;
		}
	}
	,addContour: function(vertexDim,vertices) {
		if(this.mesh == null) {
			this.mesh = new hxGeomAlgo__$Tess2_TessMesh();
		}
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		var e = null;
		var i = 0;
		while(i < vertices.length) {
			if(e == null) {
				e = this.mesh.makeEdge();
				this.mesh.splice(e,e.Sym);
			} else {
				this.mesh.splitEdge(e);
				e = e.Lnext;
			}
			e.Org.coords[0] = vertices[i];
			e.Org.coords[1] = vertices[i + 1];
			if(vertexDim > 2) {
				e.Org.coords[2] = vertices[i + 2];
			} else {
				e.Org.coords[2] = 0.0;
			}
			e.Org.idx = this.vertexIndexCounter++;
			e.winding = 1;
			e.Sym.winding = -1;
			i += vertexDim;
		}
	}
	,tesselate: function(windingRule,resultType,polySize,vertexDim,normal) {
		this.vertices = [];
		this.elements = [];
		this.vertexIndices = [];
		this.vertexIndexCounter = 0;
		if(normal != null) {
			this.normal[0] = normal[0];
			this.normal[1] = normal[1];
			this.normal[2] = normal[2];
		}
		this.windingRule = windingRule;
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		if(this.mesh == null) {
			return false;
		}
		this.projectPolygon_();
		hxGeomAlgo__$Tess2_Sweep.computeInterior(this);
		var mesh = this.mesh;
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.setWindingNumber_(mesh,1,true);
		} else {
			this.tessellateInterior_(mesh);
			if(resultType == hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY) {
				this.refineDelaunay_(mesh);
				polySize = 3;
			}
		}
		mesh.check();
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.outputContours_(mesh,vertexDim);
		} else {
			this.outputPolymesh_(mesh,resultType,polySize,vertexDim);
		}
		return true;
	}
};
var hyperKitGL_AnimateTimer = function() { };
hyperKitGL_AnimateTimer.__name__ = true;
hyperKitGL_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(hyperKitGL_AnimateTimer.loop);
	if(hyperKitGL_AnimateTimer.onFrame != null) {
		hyperKitGL_AnimateTimer.onFrame(hyperKitGL_AnimateTimer.counter);
	}
	hyperKitGL_AnimateTimer.counter++;
	return true;
};
var hyperKitGL_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
hyperKitGL_DivertTrace.__name__ = true;
hyperKitGL_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var hyperKitGL_ImageLoader = function(imageNames,loaded_,traceOut) {
	if(traceOut == null) {
		traceOut = false;
	}
	this.images = new haxe_ds_StringMap();
	if(traceOut == true) {
		this.imageLoaded = $bind(this,this.traceImageLoad);
		this.imageFinish = $bind(this,this.traceFinish);
	}
	this.imageArr = [];
	this.loaded = loaded_;
	this.count = imageNames.length;
	var _g = 0;
	while(_g < imageNames.length) {
		var name = imageNames[_g];
		++_g;
		this.load(name);
	}
};
hyperKitGL_ImageLoader.__name__ = true;
hyperKitGL_ImageLoader.prototype = {
	traceImageLoad: function(name,count) {
		haxe_Log.trace("store " + name + " " + count,{ fileName : "hyperKitGL/ImageLoader.js.hx", lineNumber : 32, className : "hyperKitGL.ImageLoader", methodName : "traceImageLoad"});
	}
	,traceFinish: function() {
		haxe_Log.trace("finish",{ fileName : "hyperKitGL/ImageLoader.js.hx", lineNumber : 35, className : "hyperKitGL.ImageLoader", methodName : "traceFinish"});
	}
	,load: function(img) {
		var image = new Image();
		var imgStyle = image.style;
		this.topLeft(image);
		var _g = $bind(this,this.store);
		var image1 = image;
		var name = img.split("/").pop();
		image.onload = function(index,e) {
			_g(image1,name,index,e);
		};
		image.src = img;
	}
	,loadEncoded: function(imageEncoded,imageNames) {
		this.count = imageNames.length;
		var _g = 0;
		var _g1 = this.count;
		while(_g < _g1) {
			var i = _g++;
			haxe_Log.trace("loadEncoded " + i + "imageNames " + imageNames[i],{ fileName : "hyperKitGL/ImageLoader.js.hx", lineNumber : 50, className : "hyperKitGL.ImageLoader", methodName : "loadEncoded"});
			this.encodedLoad(imageEncoded[i],imageNames[i],i);
		}
	}
	,encodedLoad: function(imgStr,name,index) {
		haxe_Log.trace(" load encode ",{ fileName : "hyperKitGL/ImageLoader.js.hx", lineNumber : 56, className : "hyperKitGL.ImageLoader", methodName : "encodedLoad"});
		var image = new Image();
		this.topLeft(image);
		var _g = $bind(this,this.store);
		var image1 = image;
		var name1 = name;
		var index1 = index;
		image.onload = function(e) {
			_g(image1,name1,index1,e);
		};
		image.src = imgStr;
		haxe_Log.trace(image,{ fileName : "hyperKitGL/ImageLoader.js.hx", lineNumber : 62, className : "hyperKitGL.ImageLoader", methodName : "encodedLoad"});
	}
	,topLeft: function(image) {
		var imgStyle = image.style;
		imgStyle.left = "0px";
		imgStyle.top = "0px";
		imgStyle.paddingLeft = "0px";
		imgStyle.paddingTop = "0px";
		imgStyle.position = "absolute";
	}
	,store: function(image,name,index,e) {
		this.count--;
		if(this.imageLoaded != null) {
			this.imageLoaded(name,this.count);
		}
		this.images.h[name] = image;
		this.imageArr[index] = image;
		if(this.count == 0) {
			this.loaded();
			if(this.imageFinish != null) {
				this.imageFinish();
			}
		}
	}
};
var hyperKitGL_PlyMix = function(width_,height_) {
	this.mode = 0;
	this.uvTransform = "uvTransform";
	this.uniformColor = "bgColor";
	this.uniformImage = "uImage0";
	this.vertexTexture = "vertexTexture";
	this.transformUVArr = [1.,0.,0.,0.,1.,0.,0.,0.,1.];
	this.indicesTexture = [];
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.width = width_;
	this.height = height_;
	this.mainSheet = new hyperKitGL_Sheet();
	this.mainSheet.create(this.width,this.height,true);
	this.gl = this.mainSheet.gl;
	this.imageLoader = new hyperKitGL_ImageLoader([],$bind(this,this.setup));
};
hyperKitGL_PlyMix.__name__ = true;
hyperKitGL_PlyMix.prototype = {
	setProgramMode: function(modeNew) {
		if(this.mode == modeNew) {
			return false;
		} else {
			this.gl.bindBuffer(34962,null);
			switch(modeNew) {
			case 1:
				this.gl.useProgram(this.programColor);
				this.gl.bindBuffer(34962,this.bufColor);
				var gl = this.gl;
				var program = this.programColor;
				var rgbaName = this.vertexColor;
				var inp = gl.getAttribLocation(program,this.vertexPosition);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 7 * elementBytes;
				var offBytes = 0 * elementBytes;
				gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				var inp = gl.getAttribLocation(program,rgbaName);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 7 * elementBytes;
				var offBytes = 3 * elementBytes;
				gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				this.mode = 1;
				break;
			case 2:
				this.gl.useProgram(this.programTexture);
				this.gl.bindBuffer(34962,this.bufTexture);
				var gl = this.gl;
				var program = this.programTexture;
				var rgbaName = this.vertexColor;
				var uvName = this.vertexTexture;
				var inp = gl.getAttribLocation(program,this.vertexPosition);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 9 * elementBytes;
				var offBytes = 0 * elementBytes;
				gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				var inp = gl.getAttribLocation(program,rgbaName);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 9 * elementBytes;
				var offBytes = 3 * elementBytes;
				gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				var inp = gl.getAttribLocation(program,uvName);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 9 * elementBytes;
				var offBytes = 7 * elementBytes;
				gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				this.mode = 2;
				break;
			default:
				this.mode = 0;
			}
			return true;
		}
	}
	,setup: function() {
		haxe_Log.trace(" setup ",{ fileName : "hyperKitGL/PlyMix.js.hx", lineNumber : 104, className : "hyperKitGL.PlyMix", methodName : "setup"});
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec3 vertexPosition;" + "attribute vec4 vertexColor;" + "attribute vec2 vertexTexture;" + "varying vec4 vcol;" + "varying vec2 vtexture;" + "uniform mat3 uvTransform;" + "void main(void) {" + " gl_Position = vec4( vertexPosition, 1.0);" + " vec3 texChange = uvTransform * vec3(vertexTexture, 1.0);" + " vtexture = vec2( texChange );" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "precision mediump int;" + "varying vec4 vcol;" + "varying vec2 vtexture;" + "uniform sampler2D uImage0;" + "uniform vec4 bgColor;" + "void main(void) {" + "if (vtexture.x < 0.0 || vtexture.y < 0.0 || vtexture.x > 1.0 || vtexture.y > 1.0) {" + " gl_FragColor = bgColor; " + "} else {" + "vec4 texcolor = texture2D( uImage0, vec2( vtexture.s, vtexture.t ) ).rgba * vcol;" + "texcolor.rgb *= vcol.a; " + "if( texcolor.a < 1. ){" + "texcolor = mix( bgColor, texcolor, texcolor.a ); " + "}" + "gl_FragColor = texcolor;" + "}" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programTexture = tmp;
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec3 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, 1.0);" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programColor = tmp;
		this.draw();
		var gl = this.gl;
		var image = this.img;
		var _2D = 3553;
		var texture = gl.createTexture();
		gl.bindTexture(_2D,texture);
		var pixel = new Uint8Array([255,255,255,255]);
		var _2D1 = 3553;
		gl.texImage2D(_2D1,0,6408,1,1,0,6408,5121,pixel);
		var midMap;
		var value = image.width;
		if((value & value - 1) == 0) {
			var value = image.height;
			midMap = (value & value - 1) == 0;
		} else {
			midMap = false;
		}
		if(!midMap) {
			var _2D1 = 3553;
			var linear = 9729;
			var mag = 10240;
			var min = 10241;
			gl.texParameteri(_2D1,mag,linear);
			gl.texParameteri(_2D1,min,linear);
			var _2D1 = 3553;
			var clamp = 33071;
			var _S = 10242;
			var _T = 10243;
			gl.texParameteri(_2D1,_S,clamp);
			gl.texParameteri(_2D1,_T,clamp);
		}
		gl.texImage2D(3553,0,6408,6408,5121,image);
		if(midMap) {
			gl.generateMipmap(_2D);
		}
		var _2D = 3553;
		gl.activeTexture(33984);
		gl.bindTexture(_2D,texture);
		this.tex = texture;
		var gl = this.gl;
		var program = this.programTexture;
		var data = this.dataGLtexture.get_data();
		var xyzName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var uvName = this.vertexTexture;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyzName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 9 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 9 * elementBytes;
		var offBytes = 3 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,uvName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 9 * elementBytes;
		var offBytes = 7 * elementBytes;
		gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufTexture = vbo;
		var count = 0;
		var _g = 0;
		var _g1 = this.dataGLtexture.get_size();
		while(_g < _g1) {
			var i = _g++;
			this.indicesTexture.push(count++);
			this.indicesTexture.push(count++);
			this.indicesTexture.push(count++);
		}
		var gl = this.gl;
		var indices = this.indicesTexture;
		var indexBuffer = gl.createBuffer();
		var arrBuffer = 34963;
		gl.bindBuffer(arrBuffer,indexBuffer);
		gl.bufferData(arrBuffer,new Uint16Array(indices),35044);
		gl.bindBuffer(arrBuffer,null);
		var gl = this.gl;
		var program = this.programColor;
		var data = this.dataGLcolor.get_data();
		var xyzName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyzName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 7 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 7 * elementBytes;
		var offBytes = 3 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufColor = vbo;
		var _gthis = this;
		if(hyperKitGL_AnimateTimer.s == null) {
			hyperKitGL_AnimateTimer.s = window.document.createElement("style");
			hyperKitGL_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
			window.document.getElementsByTagName("head")[0].appendChild(hyperKitGL_AnimateTimer.s);
			hyperKitGL_AnimateTimer.s.animation = "spin 1s linear infinite";
			hyperKitGL_AnimateTimer.loop(60.0);
		}
		hyperKitGL_AnimateTimer.onFrame = function(v) {
			var gl = _gthis.gl;
			var width = _gthis.width;
			var height = _gthis.height;
			gl.clearColor(0.5,0.0,0.5,0.9);
			gl.enable(2929);
			gl.clear(16384);
			gl.viewport(0,0,width,height);
			gl.enable(3042);
			gl.blendFunc(1,771);
			gl.enable(2929);
			_gthis.gl.bindBuffer(34962,_gthis.bufColor);
			_gthis.renderDraw();
		};
	}
	,draw: function() {
		haxe_Log.trace("parent draw",{ fileName : "hyperKitGL/PlyMix.js.hx", lineNumber : 149, className : "hyperKitGL.PlyMix", methodName : "draw"});
	}
	,drawTextureShape: function(start,end,bgColor) {
		var modeChange = this.setProgramMode(2);
		var gl = this.gl;
		var a = (bgColor >> 24 & 255) / 255;
		var r = (bgColor >> 16 & 255) / 255;
		var g = (bgColor >> 8 & 255) / 255;
		var b = (bgColor & 255) / 255;
		var argb_a = a;
		var argb_r = r;
		var argb_g = g;
		var argb_b = b;
		var colUniform = gl.getUniformLocation(this.programTexture,this.uniformColor);
		gl.uniform4f(colUniform,argb_r,argb_g,argb_b,argb_a);
		if(modeChange) {
			var gl = this.gl;
			var imgUniform = gl.getUniformLocation(this.programTexture,this.uniformImage);
			gl.uniform1i(imgUniform,0);
			gl.enable(2929);
			gl.enable(3042);
			gl.blendFunc(770,771);
			gl.depthMask(false);
			gl.disable(2884);
			var gl = this.gl;
			var val = this.transformUVArr;
			var uvTransform = gl.getUniformLocation(this.programTexture,this.uvTransform);
			if(val == null) {
				val = [1.,0.,0.,0.,1.,0.,0.,0.,1.];
			}
			gl.uniformMatrix3fv(uvTransform,false,val);
		}
		this.drawData(this.programTexture,this.dataGLtexture,start,end,27);
	}
	,drawColorShape: function(start,end) {
		this.setProgramMode(1);
		this.drawData(this.programColor,this.dataGLcolor,start,end,21);
	}
	,drawData: function(program,dataGL,start,end,len) {
		var partData = dataGL.get_data().subarray(start * len,end * len);
		this.gl.bufferSubData(34962,0,partData);
		this.gl.useProgram(program);
		this.gl.drawArrays(4,0,(end - start) * 3 | 0);
	}
	,renderDraw: function() {
	}
};
var hyperKitGL_Sheet = function() {
};
hyperKitGL_Sheet.__name__ = true;
hyperKitGL_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var hyperKitGL_XY = function(x,y) {
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
};
hyperKitGL_XY.__name__ = true;
var hyperKitGL_io_Float32Flat = {};
hyperKitGL_io_Float32Flat.get_size = function(this1) {
	return this1[1] | 0;
};
hyperKitGL_io_Float32Flat.set_size = function(this1,id) {
	var pos_ = id;
	this1[0] = pos_;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	return id;
};
var hyperKitGL_io_Float32FlatDepth = {};
hyperKitGL_io_Float32FlatDepth.rangeToEnd = function(this1,starting,totalLen,section) {
	var ending = starting + totalLen;
	var temp = [];
	var count = 0;
	var _g = starting;
	var _g1 = ending;
	while(_g < _g1) {
		var i = _g++;
		temp[count++] = this1[i + 2];
	}
	var left = section * hyperKitGL_io_Float32Flat.get_size(this1) - ending;
	var _g = 0;
	var _g1 = left;
	while(_g < _g1) {
		var i = _g++;
		var v = this1[ending + i + 2];
		this1[starting + i + 2] = v;
	}
	var last = section * hyperKitGL_io_Float32Flat.get_size(this1);
	var reserveTop = last - totalLen;
	count = 0;
	var _g = reserveTop;
	var _g1 = last;
	while(_g < _g1) {
		var i = _g++;
		var v = temp[count++];
		this1[i + 2] = v;
	}
	temp = null;
	return true;
};
var hyperKitGL_io_FloatColorTriangles = {};
hyperKitGL_io_FloatColorTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 21 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 21 + 1 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 1 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_az = function(this1) {
	return this1[(this1[0] | 0) * 21 + 2 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_az = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 2 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_redA = function(this1) {
	return this1[(this1[0] | 0) * 21 + 3 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 3 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 21 + 7 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 7 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 21 + 8 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 8 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_bz = function(this1) {
	return this1[(this1[0] | 0) * 21 + 9 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_bz = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 9 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_redB = function(this1) {
	return this1[(this1[0] | 0) * 21 + 10 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 10 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 21 + 14 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 14 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 21 + 15 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 15 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_cz = function(this1) {
	return this1[(this1[0] | 0) * 21 + 16 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_cz = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 16 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.get_redC = function(this1) {
	return this1[(this1[0] | 0) * 21 + 17 + 2];
};
hyperKitGL_io_FloatColorTriangles.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 17 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTriangles.triangle = function(this1,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
	hyperKitGL_io_FloatColorTriangles.set_ax(this1,ax_);
	hyperKitGL_io_FloatColorTriangles.set_ay(this1,ay_);
	hyperKitGL_io_FloatColorTriangles.set_az(this1,az_);
	hyperKitGL_io_FloatColorTriangles.set_bx(this1,bx_);
	hyperKitGL_io_FloatColorTriangles.set_by(this1,by_);
	hyperKitGL_io_FloatColorTriangles.set_bz(this1,bz_);
	hyperKitGL_io_FloatColorTriangles.set_cx(this1,cx_);
	hyperKitGL_io_FloatColorTriangles.set_cy(this1,cy_);
	hyperKitGL_io_FloatColorTriangles.set_cz(this1,cz_);
	var windingAdjusted = hyperKitGL_io_FloatColorTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		hyperKitGL_io_FloatColorTriangles.set_ax(this1,ax_);
		hyperKitGL_io_FloatColorTriangles.set_ay(this1,ay_);
		hyperKitGL_io_FloatColorTriangles.set_bx(this1,cx_);
		hyperKitGL_io_FloatColorTriangles.set_by(this1,cy_);
		hyperKitGL_io_FloatColorTriangles.set_cx(this1,bx_);
		hyperKitGL_io_FloatColorTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
hyperKitGL_io_FloatColorTriangles.adjustWinding = function(this1) {
	return hyperKitGL_io_FloatColorTriangles.get_ax(this1) * hyperKitGL_io_FloatColorTriangles.get_by(this1) - hyperKitGL_io_FloatColorTriangles.get_bx(this1) * hyperKitGL_io_FloatColorTriangles.get_ay(this1) + (hyperKitGL_io_FloatColorTriangles.get_bx(this1) * hyperKitGL_io_FloatColorTriangles.get_cy(this1) - hyperKitGL_io_FloatColorTriangles.get_cx(this1) * hyperKitGL_io_FloatColorTriangles.get_by(this1)) + (hyperKitGL_io_FloatColorTriangles.get_cx(this1) * hyperKitGL_io_FloatColorTriangles.get_ay(this1) - hyperKitGL_io_FloatColorTriangles.get_ax(this1) * hyperKitGL_io_FloatColorTriangles.get_cy(this1)) > 0;
};
hyperKitGL_io_FloatColorTriangles.moveDelta = function(this1,dx,dy) {
	hyperKitGL_io_FloatColorTriangles.set_ax(this1,hyperKitGL_io_FloatColorTriangles.get_ax(this1) + dx);
	hyperKitGL_io_FloatColorTriangles.set_ay(this1,hyperKitGL_io_FloatColorTriangles.get_ay(this1) + dy);
	hyperKitGL_io_FloatColorTriangles.set_bx(this1,hyperKitGL_io_FloatColorTriangles.get_bx(this1) + dx);
	hyperKitGL_io_FloatColorTriangles.set_by(this1,hyperKitGL_io_FloatColorTriangles.get_by(this1) + dy);
	hyperKitGL_io_FloatColorTriangles.set_cx(this1,hyperKitGL_io_FloatColorTriangles.get_cx(this1) + dx);
	hyperKitGL_io_FloatColorTriangles.set_cy(this1,hyperKitGL_io_FloatColorTriangles.get_cy(this1) + dy);
};
hyperKitGL_io_FloatColorTriangles.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_ax(this1),hyperKitGL_io_FloatColorTriangles.get_bx(this1)),hyperKitGL_io_FloatColorTriangles.get_cx(this1)) && px < Math.max(Math.max(hyperKitGL_io_FloatColorTriangles.get_ax(this1),hyperKitGL_io_FloatColorTriangles.get_bx(this1)),hyperKitGL_io_FloatColorTriangles.get_cx(this1)) && py > Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_ay(this1),hyperKitGL_io_FloatColorTriangles.get_by(this1)),hyperKitGL_io_FloatColorTriangles.get_cy(this1)) && py < Math.max(Math.max(hyperKitGL_io_FloatColorTriangles.get_ay(this1),hyperKitGL_io_FloatColorTriangles.get_by(this1)),hyperKitGL_io_FloatColorTriangles.get_cy(this1))) {
		return true;
	}
	var planeAB = (hyperKitGL_io_FloatColorTriangles.get_ax(this1) - px) * (hyperKitGL_io_FloatColorTriangles.get_by(this1) - py) - (hyperKitGL_io_FloatColorTriangles.get_bx(this1) - px) * (hyperKitGL_io_FloatColorTriangles.get_ay(this1) - py);
	var planeBC = (hyperKitGL_io_FloatColorTriangles.get_bx(this1) - px) * (hyperKitGL_io_FloatColorTriangles.get_cy(this1) - py) - (hyperKitGL_io_FloatColorTriangles.get_cx(this1) - px) * (hyperKitGL_io_FloatColorTriangles.get_by(this1) - py);
	var planeCA = (hyperKitGL_io_FloatColorTriangles.get_cx(this1) - px) * (hyperKitGL_io_FloatColorTriangles.get_ay(this1) - py) - (hyperKitGL_io_FloatColorTriangles.get_ax(this1) - px) * (hyperKitGL_io_FloatColorTriangles.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
var hyperKitGL_io_FloatColorTrianglesUV = {};
hyperKitGL_io_FloatColorTrianglesUV.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 27 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 27 + 1 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 1 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_az = function(this1) {
	return this1[(this1[0] | 0) * 27 + 2 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_az = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 2 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_redA = function(this1) {
	return this1[(this1[0] | 0) * 27 + 3 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 3 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 27 + 9 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 9 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_by = function(this1) {
	return this1[(this1[0] | 0) * 27 + 10 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 10 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_bz = function(this1) {
	return this1[(this1[0] | 0) * 27 + 11 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_bz = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 11 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_redB = function(this1) {
	return this1[(this1[0] | 0) * 27 + 12 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 12 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 27 + 18 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 18 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 27 + 19 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 19 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_cz = function(this1) {
	return this1[(this1[0] | 0) * 27 + 20 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_cz = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 20 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.get_redC = function(this1) {
	return this1[(this1[0] | 0) * 27 + 21 + 2];
};
hyperKitGL_io_FloatColorTrianglesUV.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 21 + 2] = v;
	return v;
};
hyperKitGL_io_FloatColorTrianglesUV.triangle = function(this1,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
	hyperKitGL_io_FloatColorTrianglesUV.set_ax(this1,ax_);
	hyperKitGL_io_FloatColorTrianglesUV.set_ay(this1,ay_);
	hyperKitGL_io_FloatColorTrianglesUV.set_az(this1,az_);
	hyperKitGL_io_FloatColorTrianglesUV.set_bx(this1,bx_);
	hyperKitGL_io_FloatColorTrianglesUV.set_by(this1,by_);
	hyperKitGL_io_FloatColorTrianglesUV.set_bz(this1,bz_);
	hyperKitGL_io_FloatColorTrianglesUV.set_cx(this1,cx_);
	hyperKitGL_io_FloatColorTrianglesUV.set_cy(this1,cy_);
	hyperKitGL_io_FloatColorTrianglesUV.set_cz(this1,cz_);
	var windingAdjusted = hyperKitGL_io_FloatColorTrianglesUV.adjustWinding(this1);
	if(windingAdjusted) {
		hyperKitGL_io_FloatColorTrianglesUV.set_bx(this1,cx_);
		hyperKitGL_io_FloatColorTrianglesUV.set_by(this1,cy_);
		hyperKitGL_io_FloatColorTrianglesUV.set_cx(this1,bx_);
		hyperKitGL_io_FloatColorTrianglesUV.set_cy(this1,by_);
	}
	return windingAdjusted;
};
hyperKitGL_io_FloatColorTrianglesUV.triangleUV = function(this1,uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_) {
	var windAdjust = windAdjust_ == null ? hyperKitGL_io_FloatColorTrianglesUV.adjustWinding(this1) : windAdjust_;
	this1[(this1[0] | 0) * 27 + 7 + 2] = uA_;
	this1[(this1[0] | 0) * 27 + 8 + 2] = vA_;
	if(windAdjust) {
		this1[(this1[0] | 0) * 27 + 16 + 2] = uC_;
		this1[(this1[0] | 0) * 27 + 17 + 2] = vC_;
		this1[(this1[0] | 0) * 27 + 25 + 2] = uB_;
		this1[(this1[0] | 0) * 27 + 26 + 2] = vB_;
	} else {
		this1[(this1[0] | 0) * 27 + 16 + 2] = uB_;
		this1[(this1[0] | 0) * 27 + 17 + 2] = vB_;
		this1[(this1[0] | 0) * 27 + 25 + 2] = uC_;
		this1[(this1[0] | 0) * 27 + 26 + 2] = vC_;
	}
	return windAdjust;
};
hyperKitGL_io_FloatColorTrianglesUV.adjustWinding = function(this1) {
	return hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1) * hyperKitGL_io_FloatColorTrianglesUV.get_by(this1) - hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1) * hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1) + (hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1) * hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1) - hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1) * hyperKitGL_io_FloatColorTrianglesUV.get_by(this1)) + (hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1) * hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1) - hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1) * hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1)) > 0;
};
hyperKitGL_io_FloatColorTrianglesUV.moveDelta = function(this1,dx,dy) {
	hyperKitGL_io_FloatColorTrianglesUV.set_ax(this1,hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1) + dx);
	hyperKitGL_io_FloatColorTrianglesUV.set_ay(this1,hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1) + dy);
	hyperKitGL_io_FloatColorTrianglesUV.set_bx(this1,hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1) + dx);
	hyperKitGL_io_FloatColorTrianglesUV.set_by(this1,hyperKitGL_io_FloatColorTrianglesUV.get_by(this1) + dy);
	hyperKitGL_io_FloatColorTrianglesUV.set_cx(this1,hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1) + dx);
	hyperKitGL_io_FloatColorTrianglesUV.set_cy(this1,hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1) + dy);
};
hyperKitGL_io_FloatColorTrianglesUV.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1),hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1)),hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1)) && px < Math.max(Math.max(hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1),hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1)),hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1)) && py > Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1),hyperKitGL_io_FloatColorTrianglesUV.get_by(this1)),hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1)) && py < Math.max(Math.max(hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1),hyperKitGL_io_FloatColorTrianglesUV.get_by(this1)),hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1))) {
		return true;
	}
	var planeAB = (hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_by(this1) - py) - (hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1) - py);
	var planeBC = (hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1) - py) - (hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_by(this1) - py);
	var planeCA = (hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1) - py) - (hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
hyperKitGL_io_FloatColorTrianglesUV.moveDeltaUV = function(this1,du,dv) {
	var v = this1[(this1[0] | 0) * 27 + 7 + 2] + du;
	this1[(this1[0] | 0) * 27 + 7 + 2] = v;
	var v = this1[(this1[0] | 0) * 27 + 8 + 2] + dv;
	this1[(this1[0] | 0) * 27 + 8 + 2] = v;
	var v = this1[(this1[0] | 0) * 27 + 16 + 2] + du;
	this1[(this1[0] | 0) * 27 + 16 + 2] = v;
	var v = this1[(this1[0] | 0) * 27 + 17 + 2] + dv;
	this1[(this1[0] | 0) * 27 + 17 + 2] = v;
	var v = this1[(this1[0] | 0) * 27 + 25 + 2] + du;
	this1[(this1[0] | 0) * 27 + 25 + 2] = v;
	var v = this1[(this1[0] | 0) * 27 + 26 + 2] + dv;
	this1[(this1[0] | 0) * 27 + 26 + 2] = v;
};
var hyperKitGL_iterArr_ArrayPairs = {};
hyperKitGL_iterArr_ArrayPairs._new = function(arr) {
	var this1 = arr;
	return this1;
};
var hyperKitGL_iterArr_ArrayTriple = {};
hyperKitGL_iterArr_ArrayTriple._new = function(arr) {
	var this1 = arr;
	return this1;
};
var hyperKitGLsamples_basic_Main = function(width,height) {
	this.theta = 0.;
	this.draw_Shape = [];
	this.bgQuadFill = -1;
	this.bgStarFill = -1;
	this.bgStarOutline = -65536;
	this.penNoduleTexture = new trilateral3_nodule_PenPaint();
	this.penNoduleColor = new trilateral3_nodule_PenNodule();
	hyperKitGL_PlyMix.call(this,width,height);
	haxe_Log.trace("draw",{ fileName : "../../../src/hyperKitGLsamples/basic/Main.hx", lineNumber : 62, className : "hyperKitGLsamples.basic.Main", methodName : "new"});
	this.imageLoader.loadEncoded([" data:image/jpeg;base64,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"],["Flower"]);
};
hyperKitGLsamples_basic_Main.__name__ = true;
hyperKitGLsamples_basic_Main.__super__ = hyperKitGL_PlyMix;
hyperKitGLsamples_basic_Main.prototype = $extend(hyperKitGL_PlyMix.prototype,{
	draw: function() {
		this.img = this.imageLoader.imageArr[0];
		var w = this.img.width;
		var h = this.img.height;
		var ratio = 1.;
		this.dataGLcolor = { get_data : ($_=this.penNoduleColor,$bind($_,$_.get_data)), get_size : ($_=this.penNoduleColor,$bind($_,$_.get_size))};
		this.dataGLtexture = { get_data : ($_=this.penNoduleTexture,$bind($_,$_.get_data)), get_size : ($_=this.penNoduleTexture,$bind($_,$_.get_size))};
		this.penColor = this.penNoduleColor.pen;
		this.penColor.currentColor = -1;
		this.penTexture = this.penNoduleTexture.pen;
		this.penTexture.useTexture = true;
		this.penTexture.currentColor = -1;
		this.posMin = this.penTexture.paintType.get_pos() | 0;
		this.quadShaper = new trilateral3_reShape_QuadShaper(this.penTexture,0);
		this.quadShaper.drawQuad(0.,0.,1000.,1000.);
		var ii_min = this.posMin;
		var ii_max = this.penTexture.paintType.get_pos() | 0;
		var this1 = new trilateral3_shape_IntIterStart(ii_min,ii_max);
		this.quadRange = this1;
		this.draw_Shape[this.draw_Shape.length] = new trilateral3_structure_RangeEntity(true,this.quadRange,this.bgQuadFill);
		this.sketch = new trilateral3_drawing_Sketch(this.penTexture,4,0);
		this.sketch.width = 40;
		this.penTexture.currentColor = -13057;
		this.posMin = this.penTexture.paintType.get_pos() | 0;
		this.drawStar(this.sketch,3);
		var ii_min = this.posMin;
		var ii_max = this.penTexture.paintType.get_pos() - 1 | 0;
		var this1 = new trilateral3_shape_IntIterStart(ii_min,ii_max);
		var iterRange = this.outlineStarRange = this1;
		this.draw_Shape[this.draw_Shape.length] = new trilateral3_structure_RangeEntity(true,iterRange,this.bgStarFill);
		this.penColor.currentColor = -13057;
		this.posMin = this.penColor.paintType.get_pos() | 0;
		trilateral3_drawing_Fill_triangulate(this.penColor,this.sketch,1);
		var ii_min = this.posMin;
		var ii_max = this.penColor.paintType.get_pos() - 1 | 0;
		var this1 = new trilateral3_shape_IntIterStart(ii_min,ii_max);
		this.fillStarRange = this1;
		this.draw_Shape[this.draw_Shape.length] = new trilateral3_structure_RangeEntity(false,this.fillStarRange,this.bgStarOutline);
		this.starRangeShaper = new trilateral3_reShape_RangeShaper(this.penColor,this.fillStarRange);
		this.transformUVArr = [2.,0.,0.,0.,2. / ratio,0.,0.,0.,1.];
	}
	,renderDraw: function() {
		var haveTextures = false;
		var haveColors = false;
		var _this = this.quadShaper;
		var _this1 = this.quadShaper;
		var v = _this1.start;
		_this1.pen.paintType.set_pos(v);
		var _this2 = _this1.tri;
		var _g = new hyperKitGL_XY(_this2.curr.get_x() * _this2.wid + _this2.wid,-(_this2.curr.get_y() * _this2.hi - _this2.hi)).x + Math.sin(this.theta);
		var _this1 = this.quadShaper;
		var v = _this1.start;
		_this1.pen.paintType.set_pos(v);
		var _this2 = _this1.tri;
		var val = new hyperKitGL_XY(_g,new hyperKitGL_XY(_this2.curr.get_x() * _this2.wid + _this2.wid,-(_this2.curr.get_y() * _this2.hi - _this2.hi)).y);
		var v = _this.start;
		_this.pen.paintType.set_pos(v);
		var tmp;
		var _this1 = _this.tri;
		if(_this1.curr.get_x() * _this1.wid + _this1.wid != null) {
			var _this1 = _this.tri;
			tmp = -(_this1.curr.get_y() * _this1.hi - _this1.hi) != null;
		} else {
			tmp = false;
		}
		if(tmp) {
			var _this1 = _this.tri;
			var _g = _this1.curr.get_x() * _this1.wid + _this1.wid;
			var _this1 = _this.tri;
			_this.lastXY = new hyperKitGL_XY(_g,-(_this1.curr.get_y() * _this1.hi - _this1.hi));
		}
		var _this1 = _this.tri;
		var val1 = val.x;
		var val_ = (val1 - _this1.wid) / _this1.wid;
		_this1.curr.set_x(val_);
		var val1 = val.y;
		var val_ = -(val1 - _this1.wid) / _this1.wid;
		_this1.curr.set_y(val_);
		var v = _this.start + 1;
		_this.pen.paintType.set_pos(v);
		var _this1 = _this.tri;
		var val1 = val.x;
		var val_ = (val1 - _this1.wid) / _this1.wid;
		_this1.curr.set_x(val_);
		var val1 = val.y;
		var val_ = -(val1 - _this1.wid) / _this1.wid;
		_this1.curr.set_y(val_);
		this.theta += 0.1;
		var _g = 0;
		var _g1 = this.draw_Shape;
		while(_g < _g1.length) {
			var a_shape = _g1[_g];
			++_g;
			if(a_shape.textured) {
				haveTextures = true;
				this.drawTextureShape(a_shape.range.start,a_shape.range.max,a_shape.bgColor);
			} else {
				haveColors = true;
				this.drawColorShape(a_shape.range.start,a_shape.range.max);
			}
		}
		if(!haveColors) {
			this.tempHackFix();
		}
	}
	,tempHackFix: function() {
		this.drawColorShape(0,0);
	}
	,drawStar: function(sketch,size) {
		var s = size;
		sketch.moveTo(121 * s,111 * s);
		sketch.moveTo(150 * s,25 * s);
		var x_ = 179 * s;
		var y_ = 111 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 269 * s;
		var y_ = 111 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 197 * s;
		var y_ = 165 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 223 * s;
		var y_ = 251 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 150 * s;
		var y_ = 200 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 77 * s;
		var y_ = 251 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 103 * s;
		var y_ = 165 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 31 * s;
		var y_ = 111 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 121 * s;
		var y_ = 111 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 150 * s;
		var y_ = 25 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
		var x_ = 179 * s;
		var y_ = 111 * s;
		var repeat = sketch.x == x_ && sketch.y == y_;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,x_,y_);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,x_,y_);
			}
			sketch.line(x_,y_);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = sketch.dim[sketch.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			sketch.x = x_;
			sketch.y = y_;
		}
	}
});
function hyperKitGLsamples_basic_Main_main() {
	new hyperKitGLsamples_basic_Main(1000,1000);
	var divertTrace = new hyperKitGL_DivertTrace();
	haxe_Log.trace("Basic example",{ fileName : "../../../src/hyperKitGLsamples/basic/Main.hx", lineNumber : 39, className : "hyperKitGLsamples.basic._Main.Main_Fields_", methodName : "main"});
}
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var org_poly2tri_AdvancingFront = function(head,tail) {
	this.search_node = this.head = head;
	this.tail = tail;
};
org_poly2tri_AdvancingFront.__name__ = true;
org_poly2tri_AdvancingFront.prototype = {
	locateNode: function(x) {
		var node = this.search_node;
		if(x < node.value) {
			while(true) {
				node = node.prev;
				if(!(node != null)) {
					break;
				}
				if(x >= node.value) {
					this.search_node = node;
					return node;
				}
			}
		} else {
			while(true) {
				node = node.next;
				if(!(node != null)) {
					break;
				}
				if(x < node.value) {
					this.search_node = node.prev;
					return node.prev;
				}
			}
		}
		return null;
	}
	,locatePoint: function(point) {
		var px = point.x;
		var node = this.search_node;
		var nx = node.point.x;
		if(px == nx) {
			if(!point.equals(node.point)) {
				if(point.equals(node.prev.point)) {
					node = node.prev;
				} else if(point.equals(node.next.point)) {
					node = node.next;
				} else {
					throw haxe_Exception.thrown("Invalid AdvancingFront.locatePoint call!");
				}
			}
		} else if(px < nx) {
			while(true) {
				node = node.prev;
				if(!(node != null)) {
					break;
				}
				if(point.equals(node.point)) {
					break;
				}
			}
		} else {
			while(true) {
				node = node.next;
				if(!(node != null)) {
					break;
				}
				if(point.equals(node.point)) {
					break;
				}
			}
		}
		if(node != null) {
			this.search_node = node;
		}
		return node;
	}
};
var org_poly2tri_Basin = function() {
	this.width = 0;
};
org_poly2tri_Basin.__name__ = true;
var org_poly2tri_Constants = function() { };
org_poly2tri_Constants.__name__ = true;
var org_poly2tri_Edge = function(p1,p2) {
	if(p1 == null || p2 == null) {
		throw haxe_Exception.thrown("Edge::new p1 or p2 is null");
	}
	var swap = false;
	if(p1.y > p2.y) {
		swap = true;
	} else if(p1.y == p2.y) {
		if(p1.x == p2.x) {
			throw haxe_Exception.thrown("Edge::repeat points " + Std.string(p1));
		}
		swap = p1.x > p2.x;
	}
	if(swap) {
		this.q = p1;
		this.p = p2;
	} else {
		this.p = p1;
		this.q = p2;
	}
	this.q.get_edge_list().push(this);
};
org_poly2tri_Edge.__name__ = true;
var org_poly2tri_EdgeEvent = function() {
};
org_poly2tri_EdgeEvent.__name__ = true;
var org_poly2tri_Node = function(point,triangle) {
	this.point = point;
	this.triangle = triangle;
	this.value = this.point.x;
};
org_poly2tri_Node.__name__ = true;
org_poly2tri_Node.prototype = {
	getHoleAngle: function() {
		var ax = this.next.point.x - this.point.x;
		var ay = this.next.point.y - this.point.y;
		var bx = this.prev.point.x - this.point.x;
		var by = this.prev.point.y - this.point.y;
		return Math.atan2(ax * by - ay * bx,ax * bx + ay * by);
	}
	,getBasinAngle: function() {
		return Math.atan2(this.point.y - this.next.next.point.y,this.point.x - this.next.next.point.x);
	}
};
var org_poly2tri_Orientation = function() { };
org_poly2tri_Orientation.__name__ = true;
org_poly2tri_Orientation.orient2d = function(pa,pb,pc) {
	var detleft = (pa.x - pc.x) * (pb.y - pc.y);
	var detright = (pa.y - pc.y) * (pb.x - pc.x);
	var val = detleft - detright;
	if(val > -org_poly2tri_Constants.EPSILON && val < org_poly2tri_Constants.EPSILON) {
		return 0;
	}
	if(val > 0) {
		return -1;
	}
	return 1;
};
var org_poly2tri_Point = function(x,y) {
	this.x = x;
	this.y = y;
	this.id = org_poly2tri_Point.C_ID;
	org_poly2tri_Point.C_ID++;
};
org_poly2tri_Point.__name__ = true;
org_poly2tri_Point.sortPoints = function(points) {
	points.sort(org_poly2tri_Point.cmpPoints);
};
org_poly2tri_Point.cmpPoints = function(l,r) {
	var ret = l.y - r.y;
	if(ret == 0) {
		ret = l.x - r.x;
	}
	if(ret < 0) {
		return -1;
	}
	if(ret > 0) {
		return 1;
	}
	return 0;
};
org_poly2tri_Point.prototype = {
	get_edge_list: function() {
		if(this.edge_list == null) {
			this.edge_list = [];
		}
		return this.edge_list;
	}
	,equals: function(that) {
		if(this.x == that.x) {
			return this.y == that.y;
		} else {
			return false;
		}
	}
	,toString: function() {
		return "Point(" + this.x + ", " + this.y + ")";
	}
};
var org_poly2tri_Sweep = function(context) {
	this.context = context;
};
org_poly2tri_Sweep.__name__ = true;
org_poly2tri_Sweep.nextFlipPoint = function(ep,eq,ot,op) {
	var o2d = org_poly2tri_Orientation.orient2d(eq,op,ep);
	if(o2d == 1) {
		return ot.pointCCW(op);
	} else if(o2d == -1) {
		return ot.pointCW(op);
	} else {
		throw haxe_Exception.thrown("Sweep:: [Unsupported] Sweep.NextFlipPoint: opposing point on constrained edge!");
	}
};
org_poly2tri_Sweep.prototype = {
	triangulate: function() {
		this.context.initTriangulation();
		this.context.createAdvancingFront();
		this.sweepPoints();
		this.finalizationPolygon();
	}
	,sweepPoints: function() {
		var _g = 1;
		var _g1 = this.context.points.length;
		while(_g < _g1) {
			var i = _g++;
			var point = this.context.points[i];
			var node = this.pointEvent(point);
			var _g2 = 0;
			var _g3 = point.get_edge_list().length;
			while(_g2 < _g3) {
				var j = _g2++;
				this.edgeEventByEdge(point.get_edge_list()[j],node);
			}
		}
	}
	,finalizationPolygon: function() {
		var t = this.context.front.head.next.triangle;
		var p = this.context.front.head.next.point;
		while(!t.getConstrainedEdgeCW(p)) t = t.neighborCCW(p);
		this.context.meshClean(t);
	}
	,pointEvent: function(point) {
		var node = this.context.locateNode(point);
		var new_node = this.newFrontTriangle(point,node);
		if(point.x <= node.point.x + org_poly2tri_Constants.EPSILON) {
			this.fill(node);
		}
		this.fillAdvancingFront(new_node);
		return new_node;
	}
	,edgeEventByEdge: function(edge,node) {
		this.context.edge_event.constrained_edge = edge;
		this.context.edge_event.right = edge.p.x > edge.q.x;
		if(node.triangle.isEdgeSide(edge.p,edge.q)) {
			return;
		}
		this.fillEdgeEvent(edge,node);
		this.edgeEventByPoints(edge.p,edge.q,node.triangle,edge.q);
	}
	,edgeEventByPoints: function(ep,eq,triangle,point) {
		if(triangle.isEdgeSide(ep,eq)) {
			return;
		}
		var p1 = triangle.pointCCW(point);
		var o1 = org_poly2tri_Orientation.orient2d(eq,p1,ep);
		if(o1 == 0) {
			throw haxe_Exception.thrown("Sweep.edgeEvent: Collinear not supported!");
		}
		var p2 = triangle.pointCW(point);
		var o2 = org_poly2tri_Orientation.orient2d(eq,p2,ep);
		if(o2 == 0) {
			throw haxe_Exception.thrown("Sweep.edgeEvent: Collinear not supported!");
		}
		if(o1 == o2) {
			triangle = o1 == 1 ? triangle.neighborCCW(point) : triangle.neighborCW(point);
			this.edgeEventByPoints(ep,eq,triangle,point);
		} else {
			this.flipEdgeEvent(ep,eq,triangle,point);
		}
	}
	,newFrontTriangle: function(point,node) {
		var triangle = new org_poly2tri_Triangle(point,node.point,node.next.point);
		triangle.markNeighborTriangle(node.triangle);
		this.context.addToMap(triangle);
		var new_node = new org_poly2tri_Node(point);
		new_node.next = node.next;
		new_node.prev = node;
		node.next.prev = new_node;
		node.next = new_node;
		if(!this.legalize(triangle)) {
			this.context.mapTriangleToNodes(triangle);
		}
		return new_node;
	}
	,fill: function(node) {
		var triangle = new org_poly2tri_Triangle(node.prev.point,node.point,node.next.point);
		triangle.markNeighborTriangle(node.prev.triangle);
		triangle.markNeighborTriangle(node.triangle);
		this.context.addToMap(triangle);
		node.prev.next = node.next;
		node.next.prev = node.prev;
		if(!this.legalize(triangle)) {
			this.context.mapTriangleToNodes(triangle);
		}
		this.context.removeNode(node);
	}
	,fillAdvancingFront: function(n) {
		var angle;
		var node = n.next;
		while(node.next != null) {
			angle = node.getHoleAngle();
			if(angle > org_poly2tri_Constants.PI_2 || angle < -org_poly2tri_Constants.PI_2) {
				break;
			}
			this.fill(node);
			node = node.next;
		}
		node = n.prev;
		while(node.prev != null) {
			angle = node.getHoleAngle();
			if(angle > org_poly2tri_Constants.PI_2 || angle < -org_poly2tri_Constants.PI_2) {
				break;
			}
			this.fill(node);
			node = node.prev;
		}
		if(n.next != null && n.next.next != null) {
			angle = n.getBasinAngle();
			if(angle < org_poly2tri_Constants.PI_3div4) {
				this.fillBasin(n);
			}
		}
	}
	,legalize: function(t) {
		var _g = 0;
		while(_g < 3) {
			var i = _g++;
			if(t.delaunay_edge[i]) {
				continue;
			}
			var ot = t.neighbors[i];
			if(ot != null) {
				var p = t.points[i];
				var op = ot.oppositePoint(t,p);
				var oi = ot.index(op);
				if(ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
					t.constrained_edge[i] = ot.constrained_edge[oi];
					continue;
				}
				if(org_poly2tri_Utils.insideIncircle(p,t.pointCCW(p),t.pointCW(p),op)) {
					t.delaunay_edge[i] = true;
					ot.delaunay_edge[oi] = true;
					org_poly2tri_Triangle.rotateTrianglePair(t,p,ot,op);
					var not_legalized = !this.legalize(t);
					if(not_legalized) {
						this.context.mapTriangleToNodes(t);
					}
					not_legalized = !this.legalize(ot);
					if(not_legalized) {
						this.context.mapTriangleToNodes(ot);
					}
					t.delaunay_edge[i] = false;
					ot.delaunay_edge[oi] = false;
					return true;
				}
			}
		}
		return false;
	}
	,fillBasin: function(node) {
		var tmp = org_poly2tri_Orientation.orient2d(node.point,node.next.point,node.next.next.point) == -1 ? node.next.next : node.next;
		this.context.basin.left_node = tmp;
		this.context.basin.bottom_node = this.context.basin.left_node;
		while(this.context.basin.bottom_node.next != null && this.context.basin.bottom_node.point.y >= this.context.basin.bottom_node.next.point.y) this.context.basin.bottom_node = this.context.basin.bottom_node.next;
		if(this.context.basin.bottom_node == this.context.basin.left_node) {
			return;
		}
		this.context.basin.right_node = this.context.basin.bottom_node;
		while(this.context.basin.right_node.next != null && this.context.basin.right_node.point.y < this.context.basin.right_node.next.point.y) this.context.basin.right_node = this.context.basin.right_node.next;
		if(this.context.basin.right_node == this.context.basin.bottom_node) {
			return;
		}
		this.context.basin.width = this.context.basin.right_node.point.x - this.context.basin.left_node.point.x;
		this.context.basin.left_highest = this.context.basin.left_node.point.y > this.context.basin.right_node.point.y;
		this.fillBasinReq(this.context.basin.bottom_node);
	}
	,fillBasinReq: function(node) {
		if(this.isShallow(node)) {
			return;
		}
		this.fill(node);
		if(node.prev == this.context.basin.left_node && node.next == this.context.basin.right_node) {
			return;
		} else if(node.prev == this.context.basin.left_node) {
			if(org_poly2tri_Orientation.orient2d(node.point,node.next.point,node.next.next.point) == 1) {
				return;
			}
			node = node.next;
		} else if(node.next == this.context.basin.right_node) {
			if(org_poly2tri_Orientation.orient2d(node.point,node.prev.point,node.prev.prev.point) == -1) {
				return;
			}
			node = node.prev;
		} else {
			node = node.prev.point.y < node.next.point.y ? node.prev : node.next;
		}
		this.fillBasinReq(node);
	}
	,isShallow: function(node) {
		var height = this.context.basin.left_highest ? this.context.basin.left_node.point.y - node.point.y : this.context.basin.right_node.point.y - node.point.y;
		return this.context.basin.width > height;
	}
	,fillEdgeEvent: function(edge,node) {
		if(this.context.edge_event.right) {
			this.fillRightAboveEdgeEvent(edge,node);
		} else {
			this.fillLeftAboveEdgeEvent(edge,node);
		}
	}
	,fillRightAboveEdgeEvent: function(edge,node) {
		while(node.next.point.x < edge.p.x) if(org_poly2tri_Orientation.orient2d(edge.q,node.next.point,edge.p) == -1) {
			this.fillRightBelowEdgeEvent(edge,node);
		} else {
			node = node.next;
		}
	}
	,fillRightBelowEdgeEvent: function(edge,node) {
		if(node.point.x >= edge.p.x) {
			return;
		}
		if(org_poly2tri_Orientation.orient2d(node.point,node.next.point,node.next.next.point) == -1) {
			this.fillRightConcaveEdgeEvent(edge,node);
		} else {
			this.fillRightConvexEdgeEvent(edge,node);
			this.fillRightBelowEdgeEvent(edge,node);
		}
	}
	,fillRightConcaveEdgeEvent: function(edge,node) {
		this.fill(node.next);
		if(node.next.point != edge.p) {
			if(org_poly2tri_Orientation.orient2d(edge.q,node.next.point,edge.p) == -1) {
				if(org_poly2tri_Orientation.orient2d(node.point,node.next.point,node.next.next.point) == -1) {
					this.fillRightConcaveEdgeEvent(edge,node);
				}
			}
		}
	}
	,fillRightConvexEdgeEvent: function(edge,node) {
		if(org_poly2tri_Orientation.orient2d(node.next.point,node.next.next.point,node.next.next.next.point) == -1) {
			this.fillRightConcaveEdgeEvent(edge,node.next);
		} else if(org_poly2tri_Orientation.orient2d(edge.q,node.next.next.point,edge.p) == -1) {
			this.fillRightConvexEdgeEvent(edge,node.next);
		}
	}
	,fillLeftAboveEdgeEvent: function(edge,node) {
		while(node.prev.point.x > edge.p.x) if(org_poly2tri_Orientation.orient2d(edge.q,node.prev.point,edge.p) == 1) {
			this.fillLeftBelowEdgeEvent(edge,node);
		} else {
			node = node.prev;
		}
	}
	,fillLeftBelowEdgeEvent: function(edge,node) {
		if(node.point.x > edge.p.x) {
			if(org_poly2tri_Orientation.orient2d(node.point,node.prev.point,node.prev.prev.point) == 1) {
				this.fillLeftConcaveEdgeEvent(edge,node);
			} else {
				this.fillLeftConvexEdgeEvent(edge,node);
				this.fillLeftBelowEdgeEvent(edge,node);
			}
		}
	}
	,fillLeftConvexEdgeEvent: function(edge,node) {
		if(org_poly2tri_Orientation.orient2d(node.prev.point,node.prev.prev.point,node.prev.prev.prev.point) == 1) {
			this.fillLeftConcaveEdgeEvent(edge,node.prev);
		} else if(org_poly2tri_Orientation.orient2d(edge.q,node.prev.prev.point,edge.p) == 1) {
			this.fillLeftConvexEdgeEvent(edge,node.prev);
		}
	}
	,fillLeftConcaveEdgeEvent: function(edge,node) {
		this.fill(node.prev);
		if(node.prev.point != edge.p) {
			if(org_poly2tri_Orientation.orient2d(edge.q,node.prev.point,edge.p) == 1) {
				if(org_poly2tri_Orientation.orient2d(node.point,node.prev.point,node.prev.prev.point) == 1) {
					this.fillLeftConcaveEdgeEvent(edge,node);
				}
			}
		}
	}
	,flipEdgeEvent: function(ep,eq,t,p) {
		var ot = t.neighborAcross(p);
		if(ot == null) {
			throw haxe_Exception.thrown("Sweep::[BUG:FIXME] FLIP failed due to missing triangle!");
		}
		var op = ot.oppositePoint(t,p);
		if(org_poly2tri_Utils.inScanArea(p,t.pointCCW(p),t.pointCW(p),op)) {
			org_poly2tri_Triangle.rotateTrianglePair(t,p,ot,op);
			this.context.mapTriangleToNodes(t);
			this.context.mapTriangleToNodes(ot);
			if(p == eq && op == ep) {
				if(eq == this.context.edge_event.constrained_edge.q && ep == this.context.edge_event.constrained_edge.p) {
					t.markConstrainedEdgeByPoints(ep,eq);
					ot.markConstrainedEdgeByPoints(ep,eq);
					this.legalize(t);
					this.legalize(ot);
				}
			} else {
				var o = org_poly2tri_Orientation.orient2d(eq,op,ep);
				t = this.nextFlipTriangle(o,t,ot,p,op);
				this.flipEdgeEvent(ep,eq,t,p);
			}
		} else {
			var newP = org_poly2tri_Sweep.nextFlipPoint(ep,eq,ot,op);
			this.flipScanEdgeEvent(ep,eq,t,ot,newP);
			this.edgeEventByPoints(ep,eq,t,p);
		}
	}
	,nextFlipTriangle: function(o,t,ot,p,op) {
		var edge_index;
		if(o == -1) {
			edge_index = ot.edgeIndex(p,op);
			ot.delaunay_edge[edge_index] = true;
			this.legalize(ot);
			ot.clearDelunayEdges();
			return t;
		}
		edge_index = t.edgeIndex(p,op);
		t.delaunay_edge[edge_index] = true;
		this.legalize(t);
		t.clearDelunayEdges();
		return ot;
	}
	,flipScanEdgeEvent: function(ep,eq,flip_triangle,t,p) {
		var ot = t.neighborAcross(p);
		if(ot == null) {
			throw haxe_Exception.thrown("Sweep::[BUG:FIXME] FLIP failed due to missing triangle");
		}
		var op = ot.oppositePoint(t,p);
		if(org_poly2tri_Utils.inScanArea(eq,flip_triangle.pointCCW(eq),flip_triangle.pointCW(eq),op)) {
			this.flipEdgeEvent(eq,op,ot,op);
		} else {
			var newP = org_poly2tri_Sweep.nextFlipPoint(ep,eq,ot,op);
			this.flipScanEdgeEvent(ep,eq,flip_triangle,ot,newP);
		}
	}
};
var org_poly2tri_SweepContext = function() {
	this.triangles = [];
	this.points = [];
	this.edge_list = [];
	this.map = new haxe_ds_StringMap();
	this.basin = new org_poly2tri_Basin();
	this.edge_event = new org_poly2tri_EdgeEvent();
};
org_poly2tri_SweepContext.__name__ = true;
org_poly2tri_SweepContext.prototype = {
	addPoints: function(points) {
		var _g = 0;
		while(_g < points.length) {
			var point = points[_g];
			++_g;
			this.points.push(point);
		}
	}
	,addPolyline: function(polyline) {
		this.initEdges(polyline);
		this.addPoints(polyline);
	}
	,initEdges: function(polyline) {
		var _g = 0;
		var _g1 = polyline.length;
		while(_g < _g1) {
			var n = _g++;
			var nx = polyline[(n + 1) % polyline.length];
			this.edge_list.push(new org_poly2tri_Edge(polyline[n],nx));
		}
	}
	,addToMap: function(triangle) {
		var this1 = this.map;
		var key = triangle.toString();
		this1.h[key] = triangle;
	}
	,initTriangulation: function() {
		var xmin = this.points[0].x;
		var xmax = this.points[0].x;
		var ymin = this.points[0].y;
		var ymax = this.points[0].y;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p.x > xmax) {
				xmax = p.x;
			}
			if(p.x < xmin) {
				xmin = p.x;
			}
			if(p.y > ymax) {
				ymax = p.y;
			}
			if(p.y < ymin) {
				ymin = p.y;
			}
		}
		var dx = org_poly2tri_Constants.kAlpha * (xmax - xmin);
		var dy = org_poly2tri_Constants.kAlpha * (ymax - ymin);
		this.head = new org_poly2tri_Point(xmax + dx,ymin - dy);
		this.tail = new org_poly2tri_Point(xmin - dy,ymin - dy);
		org_poly2tri_Point.sortPoints(this.points);
	}
	,locateNode: function(point) {
		return this.front.locateNode(point.x);
	}
	,createAdvancingFront: function() {
		var triangle = new org_poly2tri_Triangle(this.points[0],this.tail,this.head);
		this.addToMap(triangle);
		var head = new org_poly2tri_Node(triangle.points[1],triangle);
		var middle = new org_poly2tri_Node(triangle.points[0],triangle);
		var tail = new org_poly2tri_Node(triangle.points[2]);
		this.front = new org_poly2tri_AdvancingFront(head,tail);
		head.next = middle;
		middle.next = tail;
		middle.prev = head;
		tail.prev = middle;
	}
	,removeNode: function(node) {
	}
	,mapTriangleToNodes: function(triangle) {
		if(triangle.neighbors[0] == null) {
			var neighbor = this.front.locatePoint(triangle.pointCW(triangle.points[0]));
			if(neighbor != null) {
				neighbor.triangle = triangle;
			}
		}
		if(triangle.neighbors[1] == null) {
			var neighbor = this.front.locatePoint(triangle.pointCW(triangle.points[1]));
			if(neighbor != null) {
				neighbor.triangle = triangle;
			}
		}
		if(triangle.neighbors[2] == null) {
			var neighbor = this.front.locatePoint(triangle.pointCW(triangle.points[2]));
			if(neighbor != null) {
				neighbor.triangle = triangle;
			}
		}
	}
	,meshClean: function(t) {
		var tmp = [t];
		while(true) {
			var t = tmp.pop();
			if(t == null) {
				break;
			}
			if(t.interior) {
				continue;
			}
			t.interior = true;
			this.triangles.push(t);
			if(!t.constrained_edge[0]) {
				tmp.push(t.neighbors[0]);
			}
			if(!t.constrained_edge[1]) {
				tmp.push(t.neighbors[1]);
			}
			if(!t.constrained_edge[2]) {
				tmp.push(t.neighbors[2]);
			}
		}
	}
};
var org_poly2tri_Triangle = function(p1,p2,p3,fixOrientation,checkOrientation) {
	if(checkOrientation == null) {
		checkOrientation = true;
	}
	if(fixOrientation == null) {
		fixOrientation = false;
	}
	if(fixOrientation) {
		if(org_poly2tri_Orientation.orient2d(p1,p2,p3) == 1) {
			var pt = p3;
			p3 = p2;
			p2 = pt;
		}
	}
	if(checkOrientation && org_poly2tri_Orientation.orient2d(p3,p2,p1) != 1) {
		throw haxe_Exception.thrown("Triangle::Triangle must defined with Orientation.CW");
	}
	this.points = [p1,p2,p3];
	this.neighbors = [null,null,null];
	this.constrained_edge = [false,false,false];
	this.delaunay_edge = [false,false,false];
};
org_poly2tri_Triangle.__name__ = true;
org_poly2tri_Triangle.rotateTrianglePair = function(t,p,ot,op) {
	var n1 = t.neighborCCW(p);
	var n2 = t.neighborCW(p);
	var n3 = ot.neighborCCW(op);
	var n4 = ot.neighborCW(op);
	var ce1 = t.getConstrainedEdgeCCW(p);
	var ce2 = t.getConstrainedEdgeCW(p);
	var ce3 = ot.getConstrainedEdgeCCW(op);
	var ce4 = ot.getConstrainedEdgeCW(op);
	var de1 = t.getDelaunayEdgeCCW(p);
	var de2 = t.getDelaunayEdgeCW(p);
	var de3 = ot.getDelaunayEdgeCCW(op);
	var de4 = ot.getDelaunayEdgeCW(op);
	t.legalize(p,op);
	ot.legalize(op,p);
	ot.setDelaunayEdgeCCW(p,de1);
	t.setDelaunayEdgeCW(p,de2);
	t.setDelaunayEdgeCCW(op,de3);
	ot.setDelaunayEdgeCW(op,de4);
	ot.setConstrainedEdgeCCW(p,ce1);
	t.setConstrainedEdgeCW(p,ce2);
	t.setConstrainedEdgeCCW(op,ce3);
	ot.setConstrainedEdgeCW(op,ce4);
	t.clearNeigbors();
	ot.clearNeigbors();
	if(n1 != null) {
		ot.markNeighborTriangle(n1);
	}
	if(n2 != null) {
		t.markNeighborTriangle(n2);
	}
	if(n3 != null) {
		t.markNeighborTriangle(n3);
	}
	if(n4 != null) {
		ot.markNeighborTriangle(n4);
	}
	t.markNeighborTriangle(ot);
};
org_poly2tri_Triangle.prototype = {
	containsPoint: function(point) {
		if(!(point.equals(this.points[0]) || point.equals(this.points[1]))) {
			return point.equals(this.points[2]);
		} else {
			return true;
		}
	}
	,containsEdgePoints: function(p1,p2) {
		if(this.containsPoint(p1)) {
			return this.containsPoint(p2);
		} else {
			return false;
		}
	}
	,markNeighbor: function(t,p1,p2) {
		if(p1.equals(this.points[2]) && p2.equals(this.points[1]) || p1.equals(this.points[1]) && p2.equals(this.points[2])) {
			this.neighbors[0] = t;
			return;
		}
		if(p1.equals(this.points[0]) && p2.equals(this.points[2]) || p1.equals(this.points[2]) && p2.equals(this.points[0])) {
			this.neighbors[1] = t;
			return;
		}
		if(p1.equals(this.points[0]) && p2.equals(this.points[1]) || p1.equals(this.points[1]) && p2.equals(this.points[0])) {
			this.neighbors[2] = t;
			return;
		}
		throw haxe_Exception.thrown("Invalid markNeighbor call (1)!");
	}
	,markNeighborTriangle: function(that) {
		if(that.containsEdgePoints(this.points[1],this.points[2])) {
			this.neighbors[0] = that;
			that.markNeighbor(this,this.points[1],this.points[2]);
			return;
		}
		if(that.containsEdgePoints(this.points[0],this.points[2])) {
			this.neighbors[1] = that;
			that.markNeighbor(this,this.points[0],this.points[2]);
			return;
		}
		if(that.containsEdgePoints(this.points[0],this.points[1])) {
			this.neighbors[2] = that;
			that.markNeighbor(this,this.points[0],this.points[1]);
			return;
		}
	}
	,getPointIndexOffset: function(p,offset) {
		if(offset == null) {
			offset = 0;
		}
		var no = offset;
		while(no < 0) no += 3;
		while(no > 2) no -= 3;
		if(p.equals(this.points[0])) {
			return no;
		}
		++no;
		while(no < 0) no += 3;
		while(no > 2) no -= 3;
		if(p.equals(this.points[1])) {
			return no;
		}
		++no;
		while(no < 0) no += 3;
		while(no > 2) no -= 3;
		if(p.equals(this.points[2])) {
			return no;
		}
		++no;
		throw haxe_Exception.thrown("Triangle::Point not in triangle");
	}
	,pointCW: function(p) {
		return this.points[this.getPointIndexOffset(p,-1)];
	}
	,pointCCW: function(p) {
		return this.points[this.getPointIndexOffset(p,1)];
	}
	,neighborCW: function(p) {
		return this.neighbors[this.getPointIndexOffset(p,1)];
	}
	,neighborCCW: function(p) {
		return this.neighbors[this.getPointIndexOffset(p,-1)];
	}
	,getConstrainedEdgeCW: function(p) {
		return this.constrained_edge[this.getPointIndexOffset(p,1)];
	}
	,setConstrainedEdgeCW: function(p,ce) {
		return this.constrained_edge[this.getPointIndexOffset(p,1)] = ce;
	}
	,getConstrainedEdgeCCW: function(p) {
		return this.constrained_edge[this.getPointIndexOffset(p,-1)];
	}
	,setConstrainedEdgeCCW: function(p,ce) {
		return this.constrained_edge[this.getPointIndexOffset(p,-1)] = ce;
	}
	,getDelaunayEdgeCW: function(p) {
		return this.delaunay_edge[this.getPointIndexOffset(p,1)];
	}
	,setDelaunayEdgeCW: function(p,e) {
		return this.delaunay_edge[this.getPointIndexOffset(p,1)] = e;
	}
	,getDelaunayEdgeCCW: function(p) {
		return this.delaunay_edge[this.getPointIndexOffset(p,-1)];
	}
	,setDelaunayEdgeCCW: function(p,e) {
		return this.delaunay_edge[this.getPointIndexOffset(p,-1)] = e;
	}
	,neighborAcross: function(p) {
		return this.neighbors[this.getPointIndexOffset(p,0)];
	}
	,oppositePoint: function(t,p) {
		return this.pointCW(t.pointCW(p));
	}
	,legalize: function(opoint,npoint) {
		if(npoint == null) {
			this.legalize(this.points[0],opoint);
			return;
		}
		if(opoint.equals(this.points[0])) {
			this.points[1] = this.points[0];
			this.points[0] = this.points[2];
			this.points[2] = npoint;
		} else if(opoint.equals(this.points[1])) {
			this.points[2] = this.points[1];
			this.points[1] = this.points[0];
			this.points[0] = npoint;
		} else if(opoint.equals(this.points[2])) {
			this.points[0] = this.points[2];
			this.points[2] = this.points[1];
			this.points[1] = npoint;
		} else {
			throw haxe_Exception.thrown("Invalid js.poly2tri.Triangle.Legalize call!");
		}
	}
	,index: function(p) {
		try {
			return this.getPointIndexOffset(p,0);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(typeof(_g1) == "string") {
				var msg = _g1;
				haxe_Log.trace(msg,{ fileName : "org/poly2tri/Triangle.hx", lineNumber : 235, className : "org.poly2tri.Triangle", methodName : "index"});
			} else {
				throw _g;
			}
		}
		return -1;
	}
	,edgeIndex: function(p1,p2) {
		if(p1.equals(this.points[0])) {
			if(p2.equals(this.points[1])) {
				return 2;
			}
			if(p2.equals(this.points[2])) {
				return 1;
			}
		} else if(p1.equals(this.points[1])) {
			if(p2.equals(this.points[2])) {
				return 0;
			}
			if(p2.equals(this.points[0])) {
				return 2;
			}
		} else if(p1.equals(this.points[2])) {
			if(p2.equals(this.points[0])) {
				return 1;
			}
			if(p2.equals(this.points[1])) {
				return 0;
			}
		}
		return -1;
	}
	,markConstrainedEdgeByIndex: function(index) {
		this.constrained_edge[index] = true;
	}
	,markConstrainedEdgeByPoints: function(p,q) {
		if(q.equals(this.points[0]) && p.equals(this.points[1]) || q.equals(this.points[1]) && p.equals(this.points[0])) {
			this.constrained_edge[2] = true;
			return;
		}
		if(q.equals(this.points[0]) && p.equals(this.points[2]) || q.equals(this.points[2]) && p.equals(this.points[0])) {
			this.constrained_edge[1] = true;
			return;
		}
		if(q.equals(this.points[1]) && p.equals(this.points[2]) || q.equals(this.points[2]) && p.equals(this.points[1])) {
			this.constrained_edge[0] = true;
			return;
		}
	}
	,isEdgeSide: function(ep,eq) {
		var index = this.edgeIndex(ep,eq);
		if(index == -1) {
			return false;
		}
		this.markConstrainedEdgeByIndex(index);
		var that = this.neighbors[index];
		if(that != null) {
			that.markConstrainedEdgeByPoints(ep,eq);
		}
		return true;
	}
	,clearNeigbors: function() {
		this.neighbors[0] = null;
		this.neighbors[1] = null;
		this.neighbors[2] = null;
	}
	,clearDelunayEdges: function() {
		this.delaunay_edge[0] = false;
		this.delaunay_edge[1] = false;
		this.delaunay_edge[2] = false;
	}
	,toString: function() {
		return "Triangle(" + Std.string(this.points[0]) + ", " + Std.string(this.points[1]) + ", " + Std.string(this.points[2]) + ")";
	}
};
var org_poly2tri_Utils = function() { };
org_poly2tri_Utils.__name__ = true;
org_poly2tri_Utils.insideIncircle = function(pa,pb,pc,pd) {
	var adx = pa.x - pd.x;
	var ady = pa.y - pd.y;
	var bdx = pb.x - pd.x;
	var bdy = pb.y - pd.y;
	var adxbdy = adx * bdy;
	var bdxady = bdx * ady;
	var oabd = adxbdy - bdxady;
	if(oabd <= 0) {
		return false;
	}
	var cdx = pc.x - pd.x;
	var cdy = pc.y - pd.y;
	var cdxady = cdx * ady;
	var adxcdy = adx * cdy;
	var ocad = cdxady - adxcdy;
	if(ocad <= 0) {
		return false;
	}
	var bdxcdy = bdx * cdy;
	var cdxbdy = cdx * bdy;
	var alift = adx * adx + ady * ady;
	var blift = bdx * bdx + bdy * bdy;
	var clift = cdx * cdx + cdy * cdy;
	var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
	return det > 0;
};
org_poly2tri_Utils.inScanArea = function(pa,pb,pc,pd) {
	var pdx = pd.x;
	var pdy = pd.y;
	var adx = pa.x - pdx;
	var ady = pa.y - pdy;
	var bdx = pb.x - pdx;
	var bdy = pb.y - pdy;
	var adxbdy = adx * bdy;
	var bdxady = bdx * ady;
	var oabd = adxbdy - bdxady;
	if(oabd <= org_poly2tri_Constants.EPSILON) {
		return false;
	}
	var cdx = pc.x - pdx;
	var cdy = pc.y - pdy;
	var cdxady = cdx * ady;
	var adxcdy = adx * cdy;
	var ocad = cdxady - adxcdy;
	if(ocad <= org_poly2tri_Constants.EPSILON) {
		return false;
	}
	return true;
};
var org_poly2tri_VisiblePolygon = function() {
	this.reset();
};
org_poly2tri_VisiblePolygon.__name__ = true;
org_poly2tri_VisiblePolygon.prototype = {
	addPolyline: function(polyline) {
		this.sweepContext.addPolyline(polyline);
	}
	,reset: function() {
		this.sweepContext = new org_poly2tri_SweepContext();
		this.sweep = new org_poly2tri_Sweep(this.sweepContext);
		this.triangulated = false;
	}
	,performTriangulationOnce: function() {
		if(this.triangulated) {
			return;
		}
		this.triangulated = true;
		this.sweep.triangulate();
	}
	,getVerticesAndTriangles: function() {
		if(!this.triangulated) {
			return null;
		}
		var vertices = [];
		var ids = [];
		var _g = 0;
		var _g1 = this.sweepContext.points.length;
		while(_g < _g1) {
			var i = _g++;
			var p = this.sweepContext.points[i];
			vertices.push(p.x);
			vertices.push(p.y);
			vertices.push(0);
			ids[p.id] = i;
		}
		var tris = [];
		var _g = 0;
		var _g1 = this.sweepContext.triangles;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			tris.push(ids[t.points[0].id]);
			tris.push(ids[t.points[1].id]);
			tris.push(ids[t.points[2].id]);
		}
		return { vertices : vertices, triangles : tris};
	}
};
var trilateral3_Trilateral = function() { };
trilateral3_Trilateral.__name__ = true;
var trilateral3_drawing_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
trilateral3_drawing_Contour.__name__ = true;
trilateral3_drawing_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.paintType.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.jxOld;
				var cy = this.jyOld;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
			var v = this.quadIndex;
			this.pen.paintType.set_pos(v);
			var _this = this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this.currentColor;
			}
			var ax = this.kax;
			var ay = this.kay;
			var bx = this.kbx;
			var by = this.kby;
			var cx = this.jx;
			var cy = this.jy;
			var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this.paintType.cornerColors(color,color,color);
			_this.paintType.next();
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.jx;
				var cy = this.jy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.jx;
				var cy = this.jy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
		}
		if(!clockWise && !this.lastClock) {
			var v = this.quadIndex;
			this.pen.paintType.set_pos(v);
			var _this = this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this.currentColor;
			}
			var ax = this.kax;
			var ay = this.kay;
			var bx = this.jx;
			var by = this.jy;
			var cx = this.kcx;
			var cy = this.kcy;
			var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this.paintType.cornerColors(color,color,color);
			_this.paintType.next();
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.jxOld;
				var cy = this.jyOld;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.kcx;
				var cy = this.kcy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.kcx;
				var cy = this.kcy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
		}
		this.pen.paintType.set_pos(currQuadIndex);
	}
};
function trilateral3_drawing_Fill_triangulate(pen,sketch,fillForm) {
	var vert;
	var tri;
	var p;
	switch(fillForm) {
	case 0:
		sketch.pointsRewound();
		p = sketch.points;
		var res = hxGeomAlgo_Tess2.tesselate(p,null,hxGeomAlgo_ResultType.POLYGONS,3);
		vert = res.vertices;
		tri = res.elements;
		var triples = hyperKitGL_iterArr_ArrayTriple._new(tri);
		var _g = 0;
		while(_g < (triples.length / 3 | 0)) {
			var i = _g * 3 | 0;
			var tri__a = triples[i];
			var tri__b = triples[i + 1];
			var tri__c = triples[i + 2];
			++_g;
			var a = tri__a * 2 | 0;
			var b = tri__b * 2 | 0;
			var c = tri__c * 2 | 0;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = pen.currentColor;
			}
			var ax = vert[a];
			var ay = vert[a + 1];
			var bx = vert[b];
			var by = vert[b + 1];
			var cx = vert[c];
			var cy = vert[c + 1];
			var windAdjust = pen.paintType.triangle(ax,ay,pen.z2D,bx,by,pen.z2D,cx,cy,pen.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				pen.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(pen.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				pen.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			pen.paintType.cornerColors(color,color,color);
			pen.paintType.next();
		}
		break;
	case 1:
		p = sketch.points;
		var l = p.length;
		var count = 0;
		vert = [];
		tri = [];
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i = _g++;
			if(p[i].length != 0) {
				var poly = p[i];
				var n = poly.length >> 1;
				var tgs;
				if(n < 3) {
					tgs = [];
				} else {
					var tgs1 = [];
					var avl = [];
					var _g2 = 0;
					var _g3 = n;
					while(_g2 < _g3) {
						var i1 = _g2++;
						avl.push(i1);
					}
					var i2 = 0;
					var al = n;
					var i0;
					var i11;
					var i21;
					var ax;
					var ay;
					var bx;
					var by;
					var cx;
					var cy;
					var earFound;
					while(al > 3) {
						i0 = avl[i2 % al];
						i11 = avl[(i2 + 1) % al];
						i21 = avl[(i2 + 2) % al];
						ax = poly[2 * i0];
						ay = poly[2 * i0 + 1];
						bx = poly[2 * i11];
						by = poly[2 * i11 + 1];
						cx = poly[2 * i21];
						cy = poly[2 * i21 + 1];
						earFound = false;
						if((ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0) {
							earFound = true;
							var _g4 = 0;
							var _g5 = al;
							while(_g4 < _g5) {
								var j = _g4++;
								var vi = avl[j];
								if(vi == i0 || vi == i11 || vi == i21) {
									continue;
								}
								var v0x = cx - ax;
								var v0y = cy - ay;
								var v1x = bx - ax;
								var v1y = by - ay;
								var v2x = poly[2 * vi] - ax;
								var v2y = poly[2 * vi + 1] - ay;
								var dot00 = v0x * v0x + v0y * v0y;
								var dot01 = v0x * v1x + v0y * v1y;
								var dot02 = v0x * v2x + v0y * v2y;
								var dot11 = v1x * v1x + v1y * v1y;
								var dot12 = v1x * v2x + v1y * v2y;
								var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
								var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
								var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
								if(u >= 0 && v >= 0 && u + v < 1) {
									earFound = false;
									break;
								}
							}
						}
						if(earFound) {
							tgs1.push(i0);
							tgs1.push(i11);
							tgs1.push(i21);
							avl.splice((i2 + 1) % al,1);
							--al;
							i2 = 0;
						} else if(i2++ > 3 * al) {
							break;
						}
					}
					tgs1.push(avl[0]);
					tgs1.push(avl[1]);
					tgs1.push(avl[2]);
					tgs = tgs1;
				}
				var triples = hyperKitGL_iterArr_ArrayTriple._new(tgs);
				var _g6 = 0;
				while(_g6 < (triples.length / 3 | 0)) {
					var i3 = _g6 * 3 | 0;
					var tri__a = triples[i3];
					var tri__b = triples[i3 + 1];
					var tri__c = triples[i3 + 2];
					++_g6;
					var a = tri__a * 2 | 0;
					var b = tri__b * 2 | 0;
					var c = tri__c * 2 | 0;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = pen.currentColor;
					}
					var ax1 = poly[a];
					var ay1 = poly[a + 1];
					var bx1 = poly[b];
					var by1 = poly[b + 1];
					var cx1 = poly[c];
					var cy1 = poly[c + 1];
					var windAdjust = pen.paintType.triangle(ax1,ay1,pen.z2D,bx1,by1,pen.z2D,cx1,cy1,pen.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						pen.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(pen.useTexture) {
						ax1 /= 2000;
						ay1 /= 2000;
						bx1 /= 2000;
						by1 /= 2000;
						cx1 /= 2000;
						cy1 /= 2000;
						pen.paintType.triangleUV(ax1,ay1,bx1,by1,cx1,cy1,windAdjust);
					}
					pen.paintType.cornerColors(color,color,color);
					pen.paintType.next();
				}
			}
		}
		break;
	case 2:
		sketch.pointsNoEndOverlap();
		p = sketch.points;
		var vp = new org_poly2tri_VisiblePolygon();
		var l = p.length;
		var p_;
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i = _g++;
			p_ = p[i];
			if(p_.length != 0) {
				var p2t = [];
				var pairs = hyperKitGL_iterArr_ArrayPairs._new(p_);
				var i1 = 0;
				var inlobj_x = pairs[i1];
				var inlobj_y = pairs[i1 + 1];
				var p0 = inlobj_x;
				var i2 = 0;
				var inlobj_x1 = pairs[i2];
				var inlobj_y1 = pairs[i2 + 1];
				var p1 = inlobj_y1;
				var _g2 = 0;
				while(_g2 < (pairs.length / 2 | 0)) {
					var i3 = _g2 * 2 | 0;
					var pair_x = pairs[i3];
					var pair_y = pairs[i3 + 1];
					++_g2;
					p2t.push(new org_poly2tri_Point(pair_x,pair_y));
				}
				var l2 = p2t.length;
				if(p0 == p2t[l2 - 1].x && p1 == p2t[l2 - 1].y) {
					p2t.pop();
				}
				vp.addPolyline(p2t);
			}
		}
		vp.performTriangulationOnce();
		var pt = vp.getVerticesAndTriangles();
		tri = pt.triangles;
		vert = pt.vertices;
		var triples = hyperKitGL_iterArr_ArrayTriple._new(tri);
		var _g = 0;
		while(_g < (triples.length / 3 | 0)) {
			var i = _g * 3 | 0;
			var tri__a = triples[i];
			var tri__b = triples[i + 1];
			var tri__c = triples[i + 2];
			++_g;
			var a = tri__a * 3 | 0;
			var b = tri__b * 3 | 0;
			var c = tri__c * 3 | 0;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = pen.currentColor;
			}
			var ax = vert[a];
			var ay = vert[a + 1];
			var bx = vert[b];
			var by = vert[b + 1];
			var cx = vert[c];
			var cy = vert[c + 1];
			var windAdjust = pen.paintType.triangle(ax,ay,pen.z2D,bx,by,pen.z2D,cx,cy,pen.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				pen.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(pen.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				pen.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			pen.paintType.cornerColors(color,color,color);
			pen.paintType.next();
		}
		break;
	}
}
var trilateral3_drawing_Pen = function(paintType_) {
	this.currentColor = 16435934;
	this.useTexture = false;
	this.z2D = 0.;
	this.paintType = paintType_;
};
trilateral3_drawing_Pen.__name__ = true;
var trilateral3_drawing_Sketch = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.contour = new trilateral3_drawing_Contour(pen_,endLine_);
	this.pen = pen_;
	this.endLine = endLine_;
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
trilateral3_drawing_Sketch.__name__ = true;
trilateral3_drawing_Sketch.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "trilateral3/drawing/Sketch.hx", lineNumber : 43, className : "trilateral3.drawing.Sketch", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "trilateral3/drawing/Sketch.hx", lineNumber : 43, className : "trilateral3.drawing.Sketch", methodName : "tracerLine"});
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = exPrev_;
		var cy = eyPrev_;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = _this.ex;
		var cy = _this.ey;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
	}
	,crudeLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = exPrev_;
		var cy = eyPrev_;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = _this.ex;
		var cy = _this.ey;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
	}
	,roundEndLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var endLineCurve = 3;
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					paintType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = x_ + radius * Math.sin(angle);
				cy = y_ + radius * Math.cos(angle);
				if(i != 0) {
					paintType.triangle(x_,y_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					paintType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = x_ + radius * Math.sin(angle);
				cy = y_ + radius * Math.cos(angle);
				if(i != 0) {
					paintType.triangle(x_,y_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			break;
		}
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = exPrev_;
		var cy = eyPrev_;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = _this.ex;
		var cy = _this.ey;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
	}
	,mediumLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = false;
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					paintType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.pen.paintType.get_pos();
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.jx;
				var by = _this.jy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			} else {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			}
		} else if(_this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,mediumOverlapLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = false;
		var overlap = true;
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && _this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					paintType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(_this.count != 0) {
				_this.addQuads(clockWise,width_);
			}
			_this.quadIndex = _this.pen.paintType.get_pos();
			if(_this.count == 0) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				if(clockWise && !_this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(clockWise && _this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && !_this.lastClock) {
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.jx;
					_this.lastClockY = _this.jy;
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.jx;
					var cy = _this.jy;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && _this.lastClock) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.jx;
					_this.penultimateCY = _this.jy;
					_this.lastClockX = _this.dx;
					_this.lastClockY = _this.dy;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.jx;
					var by = _this.jy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			} else {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			}
		} else if(_this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxOld;
					var ay = _this.dyOld;
					var bx = _this.exPrev;
					var by = _this.eyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				} else {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.exOld;
					var ay = _this.eyOld;
					var bx = _this.dxPrev;
					var by = _this.dyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			} else if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && !overlap && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,fineLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = true;
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					paintType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.pen.paintType.get_pos();
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.jx;
				var by = _this.jy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			} else {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			}
		} else if(_this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,fineOverlapLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = true;
		var overlap = true;
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && _this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var paintType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					paintType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						paintType.transform(m);
					}
					paintType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var fh = _this.pen;
			var this1 = fh.paintType;
			var v = fh.paintType.get_pos() - len;
			this1.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(_this.count != 0) {
				_this.addQuads(clockWise,width_);
			}
			_this.quadIndex = _this.pen.paintType.get_pos();
			if(_this.count == 0) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				if(clockWise && !_this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(clockWise && _this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && !_this.lastClock) {
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.jx;
					_this.lastClockY = _this.jy;
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.jx;
					var cy = _this.jy;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && _this.lastClock) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.jx;
					_this.penultimateCY = _this.jy;
					_this.lastClockX = _this.dx;
					_this.lastClockY = _this.dy;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.jx;
					var by = _this.jy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			} else {
				var _this1 = _this.pen;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color = -1;
						if(color == -1) {
							color = _this1.currentColor;
						}
						var ax = ax_;
						var ay = ay_;
						var bx1 = bx;
						var by1 = by;
						var cx1 = cx;
						var cy1 = cy;
						var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
						if(trilateral3_Trilateral.transformMatrix != null) {
							_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
						}
						if(_this1.useTexture) {
							ax /= 2000;
							ay /= 2000;
							bx1 /= 2000;
							by1 /= 2000;
							cx1 /= 2000;
							cy1 /= 2000;
							_this1.paintType.triangleUV(ax,ay,bx1,by1,cx1,cy1,windAdjust);
						}
						_this1.paintType.cornerColors(color,color,color);
						_this1.paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
			}
		} else if(_this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxOld;
					var ay = _this.dyOld;
					var bx = _this.exPrev;
					var by = _this.eyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				} else {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.exOld;
					var ay = _this.eyOld;
					var bx = _this.dxPrev;
					var by = _this.dyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			} else if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && !overlap && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,pointsNoEndOverlap: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i].pop();
				this.points[i].pop();
				l -= 2;
			}
		}
		return this.points;
	}
	,pointsRewound: function() {
		var p;
		var l;
		var j = 0;
		var pointsClean = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			if(p.length > 2) {
				pointsClean[j++] = p;
			}
		}
		this.points = pointsClean;
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			p = this.points[i];
			l = p.length;
			var repeat = p[0] == p[l - 2] && p[1] == p[l - 1];
			if(repeat) {
				this.points[i].pop();
				this.points[i].pop();
				l -= 2;
			}
			var cc = 0.;
			var k = 0;
			var x1;
			var y1;
			var x2;
			var y2;
			var last = l - 2;
			while(k < l) {
				x1 = p[k];
				y1 = p[k + 1];
				if(k == last) {
					x2 = p[0];
					y2 = p[1];
				} else {
					x2 = p[k + 2];
					y2 = p[k + 3];
				}
				cc += (x2 - x1) * (y2 + y1);
				k += 2;
			}
			this.points[i] = p;
		}
		return this.points;
	}
	,moveTo: function(x_,y_) {
		if(this.endLine == 2 || this.endLine == 3) {
			var _this = this.contour;
			var width_ = this.width;
			_this.endEdges();
			if(_this.count != 0) {
				var ax = _this.bx;
				var ay = _this.by;
				var radius = width_ / 2;
				var beta = -_this.angle1 - Math.PI / 2;
				var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
				var temp = [];
				var paintType = _this.pen.paintType;
				var sides = 36;
				if(sides == null) {
					sides = 36;
				}
				var pi = Math.PI;
				var step = pi * 2 / sides;
				var dif;
				switch(fracs_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
					break;
				case 1:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
					break;
				case 2:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var smallest = theta <= Math.PI;
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
					break;
				case 3:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var largest = theta > Math.PI;
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
					break;
				}
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = beta;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = temp.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						paintType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							paintType.transform(m);
						}
						paintType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var fh = _this.pen;
				var this1 = fh.paintType;
				var v = fh.paintType.get_pos() - len;
				this1.set_pos(v);
				var _this1 = _this.pen;
				var color = 0;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
				var pA = _this.pointsAnti.length;
				var len = temp.length / 2 | 0;
				var _g = 0;
				var _g1 = len + 2;
				while(_g < _g1) {
					var i = _g++;
					_this.pointsAnti[pA++] = temp[i];
				}
				var pC = _this.pointsClock.length;
				var _g = 1;
				var _g1 = len / 2 + 1 | 0;
				while(_g < _g1) {
					var i = _g++;
					_this.pointsClock[pC++] = temp[temp.length - 2 * i];
					_this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
				}
			}
		}
		this.x = x_;
		this.y = y_;
		var l = this.points.length;
		this.points[l] = [];
		this.points[l][0] = x_;
		this.points[l][1] = y_;
		this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
		this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.contour.reset();
	}
};
var trilateral3_geom_FlatColorTriangles = {};
trilateral3_geom_FlatColorTriangles.transform = function(this1,m) {
	var pa = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_ax(this1),hyperKitGL_io_FloatColorTriangles.get_ay(this1),hyperKitGL_io_FloatColorTriangles.get_az(this1),1.);
	var pb = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_bx(this1),hyperKitGL_io_FloatColorTriangles.get_by(this1),hyperKitGL_io_FloatColorTriangles.get_bz(this1),1.);
	var pc = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_cx(this1),hyperKitGL_io_FloatColorTriangles.get_cy(this1),hyperKitGL_io_FloatColorTriangles.get_cz(this1),1.);
	var v2 = new trilateral3_matrix_Vertex(m.a * pa.x + m.b * pa.y + m.c * pa.z + m.d,m.e * pa.x + m.f * pa.y + m.g * pa.z + m.h,m.i * pa.x + m.j * pa.y + m.k * pa.z + m.l,1.);
	pa = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pb.x + m.b * pb.y + m.c * pb.z + m.d,m.e * pb.x + m.f * pb.y + m.g * pb.z + m.h,m.i * pb.x + m.j * pb.y + m.k * pb.z + m.l,1.);
	pb = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pc.x + m.b * pc.y + m.c * pc.z + m.d,m.e * pc.x + m.f * pc.y + m.g * pc.z + m.h,m.i * pc.x + m.j * pc.y + m.k * pc.z + m.l,1.);
	pc = v2;
	hyperKitGL_io_FloatColorTriangles.set_ax(this1,pa.x);
	hyperKitGL_io_FloatColorTriangles.set_ay(this1,pa.y);
	hyperKitGL_io_FloatColorTriangles.set_az(this1,pa.z);
	hyperKitGL_io_FloatColorTriangles.set_bx(this1,pb.x);
	hyperKitGL_io_FloatColorTriangles.set_by(this1,pb.y);
	hyperKitGL_io_FloatColorTriangles.set_bz(this1,pb.z);
	hyperKitGL_io_FloatColorTriangles.set_cx(this1,pc.x);
	hyperKitGL_io_FloatColorTriangles.set_cy(this1,pc.y);
	hyperKitGL_io_FloatColorTriangles.set_cz(this1,pc.z);
};
trilateral3_geom_FlatColorTriangles.transformRange = function(this1,m,startEnd) {
	var start = startEnd.start;
	var end = startEnd.end;
	this1[0] = start;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	if(end > hyperKitGL_io_Float32Flat.get_size(this1) - 1) {
		hyperKitGL_io_Float32Flat.get_size(this1);
	}
	var _g = start;
	var _g1 = end + 1;
	while(_g < _g1) {
		var i = _g++;
		trilateral3_geom_FlatColorTriangles.transform(this1,m);
		var pos_ = this1[0] + 1.;
		this1[0] = pos_;
		if(this1[0] > this1[1] - 1) {
			this1[1] = this1[0];
		}
	}
};
var trilateral3_geom_FlatColorTrianglesUV = {};
trilateral3_geom_FlatColorTrianglesUV.transform = function(this1,m) {
	var pa = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_ax(this1),hyperKitGL_io_FloatColorTrianglesUV.get_ay(this1),hyperKitGL_io_FloatColorTrianglesUV.get_az(this1),1.);
	var pb = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_bx(this1),hyperKitGL_io_FloatColorTrianglesUV.get_by(this1),hyperKitGL_io_FloatColorTrianglesUV.get_bz(this1),1.);
	var pc = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_cx(this1),hyperKitGL_io_FloatColorTrianglesUV.get_cy(this1),hyperKitGL_io_FloatColorTrianglesUV.get_cz(this1),1.);
	var v2 = new trilateral3_matrix_Vertex(m.a * pa.x + m.b * pa.y + m.c * pa.z + m.d,m.e * pa.x + m.f * pa.y + m.g * pa.z + m.h,m.i * pa.x + m.j * pa.y + m.k * pa.z + m.l,1.);
	pa = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pb.x + m.b * pb.y + m.c * pb.z + m.d,m.e * pb.x + m.f * pb.y + m.g * pb.z + m.h,m.i * pb.x + m.j * pb.y + m.k * pb.z + m.l,1.);
	pb = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pc.x + m.b * pc.y + m.c * pc.z + m.d,m.e * pc.x + m.f * pc.y + m.g * pc.z + m.h,m.i * pc.x + m.j * pc.y + m.k * pc.z + m.l,1.);
	pc = v2;
	hyperKitGL_io_FloatColorTrianglesUV.set_ax(this1,pa.x);
	hyperKitGL_io_FloatColorTrianglesUV.set_ay(this1,pa.y);
	hyperKitGL_io_FloatColorTrianglesUV.set_az(this1,pa.z);
	hyperKitGL_io_FloatColorTrianglesUV.set_bx(this1,pb.x);
	hyperKitGL_io_FloatColorTrianglesUV.set_by(this1,pb.y);
	hyperKitGL_io_FloatColorTrianglesUV.set_bz(this1,pb.z);
	hyperKitGL_io_FloatColorTrianglesUV.set_cx(this1,pc.x);
	hyperKitGL_io_FloatColorTrianglesUV.set_cy(this1,pc.y);
	hyperKitGL_io_FloatColorTrianglesUV.set_cz(this1,pc.z);
};
trilateral3_geom_FlatColorTrianglesUV.transformRange = function(this1,m,startEnd) {
	var start = startEnd.start;
	var end = startEnd.end;
	this1[0] = start;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	if(end > hyperKitGL_io_Float32Flat.get_size(this1) - 1) {
		hyperKitGL_io_Float32Flat.get_size(this1);
	}
	var _g = start;
	var _g1 = end + 1;
	while(_g < _g1) {
		var i = _g++;
		trilateral3_geom_FlatColorTrianglesUV.transform(this1,m);
		var pos_ = this1[0] + 1.;
		this1[0] = pos_;
		if(this1[0] > this1[1] - 1) {
			this1[1] = this1[0];
		}
	}
};
var trilateral3_matrix_MatrixDozen = function(a,b,c,d,e,f,g,h,i,j,k,l) {
	this.l = 0.;
	this.k = 0.;
	this.j = 0.;
	this.i = 0.;
	this.h = 0.;
	this.g = 0.;
	this.f = 0.;
	this.e = 0.;
	this.d = 0.;
	this.c = 0.;
	this.b = 0.;
	this.a = 0.;
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.e = e;
	this.f = f;
	this.g = g;
	this.h = h;
	this.i = i;
	this.j = j;
	this.k = k;
	this.l = l;
};
trilateral3_matrix_MatrixDozen.__name__ = true;
var trilateral3_matrix_UV = function(u,v) {
	this.v = 0.;
	this.u = 0.;
	this.u = u;
	this.v = v;
};
trilateral3_matrix_UV.__name__ = true;
var trilateral3_matrix_Vertex = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	this.w = 1.;
	this.z = 0.;
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
trilateral3_matrix_Vertex.__name__ = true;
var trilateral3_nodule_PenNodule = function(useGLScale) {
	if(useGLScale == null) {
		useGLScale = true;
	}
	var this1 = new Float32Array(trilateral3_nodule_PenNodule.largeEnough + 2);
	this1[0] = 0.;
	this1[1] = 0.;
	this.colorTriangles = this1;
	if(useGLScale) {
		var transform1000 = new trilateral3_matrix_MatrixDozen(0.001,0,0,-1,0,-0.001,0,1,0,0,0.001,0);
		trilateral3_Trilateral.transformMatrix = transform1000;
	}
	this.createPen();
};
trilateral3_nodule_PenNodule.__name__ = true;
trilateral3_nodule_PenNodule.prototype = {
	createPen: function() {
		var t = this.colorTriangles;
		var _e = t;
		var _e1 = t;
		var _e2 = t;
		var _e3 = t;
		var _e4 = t;
		var _e5 = t;
		var _e6 = t;
		var _e7 = t;
		var _e8 = t;
		var _e9 = t;
		var _e10 = t;
		var _e11 = t;
		var _e12 = t;
		var _e13 = t;
		var _e14 = t;
		var _e15 = t;
		var _e16 = t;
		var triangleAbstract = { rotate : function(x,y,theta) {
			var cos = Math.cos(theta);
			var sin = Math.sin(theta);
			hyperKitGL_io_FloatColorTriangles.set_ax(_e,hyperKitGL_io_FloatColorTriangles.get_ax(_e) - x);
			hyperKitGL_io_FloatColorTriangles.set_ay(_e,hyperKitGL_io_FloatColorTriangles.get_ay(_e) - y);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e,hyperKitGL_io_FloatColorTriangles.get_bx(_e) - x);
			hyperKitGL_io_FloatColorTriangles.set_by(_e,hyperKitGL_io_FloatColorTriangles.get_by(_e) - y);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e,hyperKitGL_io_FloatColorTriangles.get_cx(_e) - x);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e,hyperKitGL_io_FloatColorTriangles.get_cy(_e) - y);
			var dx = hyperKitGL_io_FloatColorTriangles.get_ax(_e);
			var dy = hyperKitGL_io_FloatColorTriangles.get_ay(_e);
			hyperKitGL_io_FloatColorTriangles.set_ax(_e,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTriangles.set_ay(_e,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTriangles.get_bx(_e);
			dy = hyperKitGL_io_FloatColorTriangles.get_by(_e);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTriangles.set_by(_e,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTriangles.get_cx(_e);
			dy = hyperKitGL_io_FloatColorTriangles.get_cy(_e);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e,dx * sin + dy * cos);
			hyperKitGL_io_FloatColorTriangles.set_ax(_e,hyperKitGL_io_FloatColorTriangles.get_ax(_e) + x);
			hyperKitGL_io_FloatColorTriangles.set_ay(_e,hyperKitGL_io_FloatColorTriangles.get_ay(_e) + y);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e,hyperKitGL_io_FloatColorTriangles.get_bx(_e) + x);
			hyperKitGL_io_FloatColorTriangles.set_by(_e,hyperKitGL_io_FloatColorTriangles.get_by(_e) + y);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e,hyperKitGL_io_FloatColorTriangles.get_cx(_e) + x);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e,hyperKitGL_io_FloatColorTriangles.get_cy(_e) + y);
		}, moveDelta : function(dx,dy) {
			hyperKitGL_io_FloatColorTriangles.moveDelta(_e1,dx,dy);
		}, rotateTrig : function(x,y,cos,sin) {
			hyperKitGL_io_FloatColorTriangles.set_ax(_e2,hyperKitGL_io_FloatColorTriangles.get_ax(_e2) - x);
			hyperKitGL_io_FloatColorTriangles.set_ay(_e2,hyperKitGL_io_FloatColorTriangles.get_ay(_e2) - y);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e2,hyperKitGL_io_FloatColorTriangles.get_bx(_e2) - x);
			hyperKitGL_io_FloatColorTriangles.set_by(_e2,hyperKitGL_io_FloatColorTriangles.get_by(_e2) - y);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e2,hyperKitGL_io_FloatColorTriangles.get_cx(_e2) - x);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e2,hyperKitGL_io_FloatColorTriangles.get_cy(_e2) - y);
			var dx = hyperKitGL_io_FloatColorTriangles.get_ax(_e2);
			var dy = hyperKitGL_io_FloatColorTriangles.get_ay(_e2);
			hyperKitGL_io_FloatColorTriangles.set_ax(_e2,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTriangles.set_ay(_e2,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTriangles.get_bx(_e2);
			dy = hyperKitGL_io_FloatColorTriangles.get_by(_e2);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e2,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTriangles.set_by(_e2,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTriangles.get_cx(_e2);
			dy = hyperKitGL_io_FloatColorTriangles.get_cy(_e2);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e2,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e2,dx * sin + dy * cos);
			hyperKitGL_io_FloatColorTriangles.set_ax(_e2,hyperKitGL_io_FloatColorTriangles.get_ax(_e2) + x);
			hyperKitGL_io_FloatColorTriangles.set_ay(_e2,hyperKitGL_io_FloatColorTriangles.get_ay(_e2) + y);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e2,hyperKitGL_io_FloatColorTriangles.get_bx(_e2) + x);
			hyperKitGL_io_FloatColorTriangles.set_by(_e2,hyperKitGL_io_FloatColorTriangles.get_by(_e2) + y);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e2,hyperKitGL_io_FloatColorTriangles.get_cx(_e2) + x);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e2,hyperKitGL_io_FloatColorTriangles.get_cy(_e2) + y);
		}, fullHit : function(px,py) {
			return hyperKitGL_io_FloatColorTriangles.fullHit(_e3,px,py);
		}, liteHit : function(px,py) {
			var planeAB = (hyperKitGL_io_FloatColorTriangles.get_ax(_e4) - px) * (hyperKitGL_io_FloatColorTriangles.get_by(_e4) - py) - (hyperKitGL_io_FloatColorTriangles.get_bx(_e4) - px) * (hyperKitGL_io_FloatColorTriangles.get_ay(_e4) - py);
			var planeBC = (hyperKitGL_io_FloatColorTriangles.get_bx(_e4) - px) * (hyperKitGL_io_FloatColorTriangles.get_cy(_e4) - py) - (hyperKitGL_io_FloatColorTriangles.get_cx(_e4) - px) * (hyperKitGL_io_FloatColorTriangles.get_by(_e4) - py);
			var planeCA = (hyperKitGL_io_FloatColorTriangles.get_cx(_e4) - px) * (hyperKitGL_io_FloatColorTriangles.get_ay(_e4) - py) - (hyperKitGL_io_FloatColorTriangles.get_ax(_e4) - px) * (hyperKitGL_io_FloatColorTriangles.get_cy(_e4) - py);
			if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
				return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
			} else {
				return false;
			}
		}, get_bottom : function() {
			return Math.max(Math.max(hyperKitGL_io_FloatColorTriangles.get_ay(_e5),hyperKitGL_io_FloatColorTriangles.get_by(_e5)),hyperKitGL_io_FloatColorTriangles.get_cy(_e5));
		}, get_back : function() {
			return Math.max(Math.max(hyperKitGL_io_FloatColorTriangles.get_az(_e6),hyperKitGL_io_FloatColorTriangles.get_bz(_e6)),hyperKitGL_io_FloatColorTriangles.get_cz(_e6));
		}, get_right : function() {
			return Math.max(Math.max(hyperKitGL_io_FloatColorTriangles.get_ax(_e7),hyperKitGL_io_FloatColorTriangles.get_bx(_e7)),hyperKitGL_io_FloatColorTriangles.get_cx(_e7));
		}, get_x : function() {
			return Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_ax(_e8),hyperKitGL_io_FloatColorTriangles.get_bx(_e8)),hyperKitGL_io_FloatColorTriangles.get_cx(_e8));
		}, set_x : function(x) {
			var dx = x - Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_ax(_e9),hyperKitGL_io_FloatColorTriangles.get_bx(_e9)),hyperKitGL_io_FloatColorTriangles.get_cx(_e9));
			hyperKitGL_io_FloatColorTriangles.set_ax(_e9,hyperKitGL_io_FloatColorTriangles.get_ax(_e9) + dx);
			hyperKitGL_io_FloatColorTriangles.set_bx(_e9,hyperKitGL_io_FloatColorTriangles.get_bx(_e9) + dx);
			hyperKitGL_io_FloatColorTriangles.set_cx(_e9,hyperKitGL_io_FloatColorTriangles.get_cx(_e9) + dx);
			return x;
		}, get_y : function() {
			return Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_ay(_e10),hyperKitGL_io_FloatColorTriangles.get_by(_e10)),hyperKitGL_io_FloatColorTriangles.get_cy(_e10));
		}, set_y : function(y) {
			var dy = y - Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_ay(_e11),hyperKitGL_io_FloatColorTriangles.get_by(_e11)),hyperKitGL_io_FloatColorTriangles.get_cy(_e11));
			hyperKitGL_io_FloatColorTriangles.set_ay(_e11,hyperKitGL_io_FloatColorTriangles.get_ay(_e11) + dy);
			hyperKitGL_io_FloatColorTriangles.set_by(_e11,hyperKitGL_io_FloatColorTriangles.get_by(_e11) + dy);
			hyperKitGL_io_FloatColorTriangles.set_cy(_e11,hyperKitGL_io_FloatColorTriangles.get_cy(_e11) + dy);
			return y;
		}, get_z : function() {
			return Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_az(_e12),hyperKitGL_io_FloatColorTriangles.get_bz(_e12)),hyperKitGL_io_FloatColorTriangles.get_cz(_e12));
		}, set_z : function(z) {
			var dz = z - Math.min(Math.min(hyperKitGL_io_FloatColorTriangles.get_az(_e13),hyperKitGL_io_FloatColorTriangles.get_bz(_e13)),hyperKitGL_io_FloatColorTriangles.get_cz(_e13));
			hyperKitGL_io_FloatColorTriangles.set_az(_e13,hyperKitGL_io_FloatColorTriangles.get_az(_e13) + dz);
			hyperKitGL_io_FloatColorTriangles.set_bz(_e13,hyperKitGL_io_FloatColorTriangles.get_bz(_e13) + dz);
			hyperKitGL_io_FloatColorTriangles.set_cz(_e13,hyperKitGL_io_FloatColorTriangles.get_cz(_e13) + dz);
			return z;
		}, triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return hyperKitGL_io_FloatColorTriangles.triangle(_e14,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_ax(_e15),hyperKitGL_io_FloatColorTriangles.get_ay(_e15),hyperKitGL_io_FloatColorTriangles.get_az(_e15),1.);
			var pb = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_bx(_e15),hyperKitGL_io_FloatColorTriangles.get_by(_e15),hyperKitGL_io_FloatColorTriangles.get_bz(_e15),1.);
			var pc = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_cx(_e15),hyperKitGL_io_FloatColorTriangles.get_cy(_e15),hyperKitGL_io_FloatColorTriangles.get_cz(_e15),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, transform : function(m) {
			trilateral3_geom_FlatColorTriangles.transform(_e16,m);
		}};
		var _e17 = t;
		var _e18 = t;
		var _e19 = t;
		var _e20 = t;
		var _e21 = t;
		var _e22 = t;
		var _e23 = t;
		var color3Abstract = { set_argb : function(col) {
			hyperKitGL_io_FloatColorTriangles.set_redA(_e17,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 6 + 2] = v;
			hyperKitGL_io_FloatColorTriangles.set_redB(_e17,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 12 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 11 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 13 + 2] = v;
			hyperKitGL_io_FloatColorTriangles.set_redC(_e17,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 19 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 18 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 20 + 2] = v;
			return col;
		}, set_argbA : function(col) {
			hyperKitGL_io_FloatColorTriangles.set_redA(_e18,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e18[(_e18[0] | 0) * 21 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e18[(_e18[0] | 0) * 21 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e18[(_e18[0] | 0) * 21 + 6 + 2] = v;
			return col;
		}, get_argbA : function() {
			return Math.round(_e19[(_e19[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTriangles.get_redA(_e19) * 255) << 16 | Math.round(_e19[(_e19[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e19[(_e19[0] | 0) * 21 + 5 + 2] * 255);
		}, set_argbB : function(col) {
			hyperKitGL_io_FloatColorTriangles.set_redB(_e20,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e20[(_e20[0] | 0) * 21 + 12 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e20[(_e20[0] | 0) * 21 + 11 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e20[(_e20[0] | 0) * 21 + 13 + 2] = v;
			return col;
		}, get_argbB : function() {
			return Math.round(_e21[(_e21[0] | 0) * 21 + 13 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTriangles.get_redB(_e21) * 255) << 16 | Math.round(_e21[(_e21[0] | 0) * 21 + 11 + 2] * 255) << 8 | Math.round(_e21[(_e21[0] | 0) * 21 + 12 + 2] * 255);
		}, set_argbC : function(col) {
			hyperKitGL_io_FloatColorTriangles.set_redC(_e22,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e22[(_e22[0] | 0) * 21 + 19 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e22[(_e22[0] | 0) * 21 + 18 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e22[(_e22[0] | 0) * 21 + 20 + 2] = v;
			return col;
		}, get_argbC : function() {
			return Math.round(_e23[(_e23[0] | 0) * 21 + 20 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTriangles.get_redC(_e23) * 255) << 16 | Math.round(_e23[(_e23[0] | 0) * 21 + 18 + 2] * 255) << 8 | Math.round(_e23[(_e23[0] | 0) * 21 + 19 + 2] * 255);
		}};
		var _e24 = t;
		var _e25 = t;
		var _e26 = t;
		var _e27 = t;
		var _e28 = t;
		var _e29 = t;
		var _e30 = t;
		var _e31 = t;
		var _e32 = t;
		var _e33 = t;
		var _e34 = t;
		var _e35 = t;
		var _e36 = t;
		var _e37 = t;
		var _e38 = t;
		var _e39 = t;
		var paintAbstract = { triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return hyperKitGL_io_FloatColorTriangles.triangle(_e24,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, cornerColors : function(colorA,colorB,colorC) {
			hyperKitGL_io_FloatColorTriangles.set_redA(_e25,(colorA >> 16 & 255) / 255);
			var v = (colorA & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 5 + 2] = v;
			var v = (colorA >> 8 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 4 + 2] = v;
			var v = (colorA >> 24 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 6 + 2] = v;
			hyperKitGL_io_FloatColorTriangles.set_redB(_e25,(colorB >> 16 & 255) / 255);
			var v = (colorB & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 12 + 2] = v;
			var v = (colorB >> 8 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 11 + 2] = v;
			var v = (colorB >> 24 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 13 + 2] = v;
			hyperKitGL_io_FloatColorTriangles.set_redC(_e25,(colorC >> 16 & 255) / 255);
			var v = (colorC & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 19 + 2] = v;
			var v = (colorC >> 8 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 18 + 2] = v;
			var v = (colorC >> 24 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 20 + 2] = v;
		}, colorTriangles : function(color,times) {
			var _g = 0;
			var _g1 = times;
			while(_g < _g1) {
				var i = _g++;
				hyperKitGL_io_FloatColorTriangles.set_redA(_e26,(color >> 16 & 255) / 255);
				var v = (color & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 5 + 2] = v;
				var v1 = (color >> 8 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 4 + 2] = v1;
				var v2 = (color >> 24 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 6 + 2] = v2;
				hyperKitGL_io_FloatColorTriangles.set_redB(_e26,(color >> 16 & 255) / 255);
				var v3 = (color & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 12 + 2] = v3;
				var v4 = (color >> 8 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 11 + 2] = v4;
				var v5 = (color >> 24 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 13 + 2] = v5;
				hyperKitGL_io_FloatColorTriangles.set_redC(_e26,(color >> 16 & 255) / 255);
				var v6 = (color & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 19 + 2] = v6;
				var v7 = (color >> 8 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 18 + 2] = v7;
				var v8 = (color >> 24 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 20 + 2] = v8;
				var pos_ = _e26[0] + 1;
				_e26[0] = pos_;
				if(_e26[0] > _e26[1] - 1) {
					_e26[1] = _e26[0];
				}
			}
		}, getTriInt : function() {
			return new trilateral3_structure_TriInt(Math.round(_e27[(_e27[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTriangles.get_redA(_e27) * 255) << 16 | Math.round(_e27[(_e27[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e27[(_e27[0] | 0) * 21 + 5 + 2] * 255),Math.round(_e27[(_e27[0] | 0) * 21 + 13 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTriangles.get_redB(_e27) * 255) << 16 | Math.round(_e27[(_e27[0] | 0) * 21 + 11 + 2] * 255) << 8 | Math.round(_e27[(_e27[0] | 0) * 21 + 12 + 2] * 255),Math.round(_e27[(_e27[0] | 0) * 21 + 20 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTriangles.get_redC(_e27) * 255) << 16 | Math.round(_e27[(_e27[0] | 0) * 21 + 18 + 2] * 255) << 8 | Math.round(_e27[(_e27[0] | 0) * 21 + 19 + 2] * 255));
		}, transform : function(m) {
			trilateral3_geom_FlatColorTriangles.transform(_e28,m);
		}, transformRange : function(m,startEnd) {
			trilateral3_geom_FlatColorTriangles.transformRange(_e29,m,startEnd);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_ax(_e30),hyperKitGL_io_FloatColorTriangles.get_ay(_e30),hyperKitGL_io_FloatColorTriangles.get_az(_e30),1.);
			var pb = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_bx(_e30),hyperKitGL_io_FloatColorTriangles.get_by(_e30),hyperKitGL_io_FloatColorTriangles.get_bz(_e30),1.);
			var pc = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTriangles.get_cx(_e30),hyperKitGL_io_FloatColorTriangles.get_cy(_e30),hyperKitGL_io_FloatColorTriangles.get_cz(_e30),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, next : function() {
			var pos_ = _e31[0] + 1.;
			_e31[0] = pos_;
			if(_e31[0] > _e31[1] - 1) {
				_e31[1] = _e31[0];
			}
			return _e31[0];
		}, hasNext : function() {
			return _e32[0] < hyperKitGL_io_Float32Flat.get_size(_e32);
		}, get_pos : function() {
			return _e33[0];
		}, set_pos : function(pos_) {
			_e34[0] = pos_;
			if(_e34[0] > _e34[1] - 1) {
				_e34[1] = _e34[0];
			}
			return pos_;
		}, get_size : function() {
			return hyperKitGL_io_Float32Flat.get_size(_e35);
		}, set_size : function(id) {
			return hyperKitGL_io_Float32Flat.set_size(_e36,id);
		}, toStart : function(id,len) {
			var starting = id * 21;
			var totalLen = 21 * len | 0;
			if(starting == 0) {
				return false;
			} else {
				var ending = starting + totalLen;
				var temp = [];
				var count = 0;
				var _g = starting;
				var _g1 = ending;
				while(_g < _g1) {
					var i = _g++;
					temp[count] = _e37[i + 2];
					++count;
				}
				count = totalLen;
				var _g = 0;
				var _g1 = starting;
				while(_g < _g1) {
					var i = _g++;
					var v = _e37[starting - 1 - i + 2];
					_e37[ending - 1 - i + 2] = v;
				}
				count = 0;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					var v = temp[count - 2];
					_e37[i + 2] = v;
					++count;
				}
				temp = null;
				return true;
			}
		}, toEnd : function(id,len) {
			return hyperKitGL_io_Float32FlatDepth.rangeToEnd(_e38,id * 21,21 * len | 0,21 * hyperKitGL_io_Float32Flat.get_size(_e38));
		}, swap : function(id0,id1,len) {
			var start0 = id0 * 21;
			var start1 = id1 * 21;
			var totalLen = 21 * len | 0;
			if(start0 + totalLen > hyperKitGL_io_Float32Flat.get_size(_e39) && start1 + totalLen > hyperKitGL_io_Float32Flat.get_size(_e39)) {
				var temp0;
				var temp1;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					temp0 = _e39[start0 + i + 2];
					temp1 = _e39[start1 + i + 2];
					_e39[start0 + i + 2] = temp1;
					_e39[start1 + i + 2] = temp0;
				}
				return true;
			} else {
				return false;
			}
		}, triangleCurrent : triangleAbstract, color3current : color3Abstract};
		this.pen = new trilateral3_drawing_Pen(paintAbstract);
		return this.pen;
	}
	,get_data: function() {
		var this1 = this.colorTriangles;
		return this1.subarray(2,hyperKitGL_io_Float32Flat.get_size(this1) * 21 + 2);
	}
	,get_size: function() {
		return hyperKitGL_io_Float32Flat.get_size(this.colorTriangles) * 3 | 0;
	}
};
var trilateral3_nodule_PenPaint = function(useGLScale) {
	if(useGLScale == null) {
		useGLScale = true;
	}
	var this1 = new Float32Array(trilateral3_nodule_PenPaint.largeEnough + 2);
	this1[0] = 0.;
	this1[1] = 0.;
	this.colorTriangles = this1;
	if(useGLScale) {
		var transform1000 = new trilateral3_matrix_MatrixDozen(0.001,0,0,-1,0,-0.001,0,1,0,0,0.001,0);
		trilateral3_Trilateral.transformMatrix = transform1000;
	}
	this.createPen();
};
trilateral3_nodule_PenPaint.__name__ = true;
trilateral3_nodule_PenPaint.prototype = {
	createPen: function() {
		var t = this.colorTriangles;
		var _e = t;
		var _e1 = t;
		var _e2 = t;
		var _e3 = t;
		var _e4 = t;
		var _e5 = t;
		var _e6 = t;
		var _e7 = t;
		var _e8 = t;
		var _e9 = t;
		var _e10 = t;
		var _e11 = t;
		var _e12 = t;
		var _e13 = t;
		var _e14 = t;
		var _e15 = t;
		var _e16 = t;
		var triangleAbstract = { rotate : function(x,y,theta) {
			var cos = Math.cos(theta);
			var sin = Math.sin(theta);
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e,hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e) - x);
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e,hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e) - y);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e,hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e) - x);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e,hyperKitGL_io_FloatColorTrianglesUV.get_by(_e) - y);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e,hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e) - x);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e,hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e) - y);
			var dx = hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e);
			var dy = hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e);
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e);
			dy = hyperKitGL_io_FloatColorTrianglesUV.get_by(_e);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e);
			dy = hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e,dx * sin + dy * cos);
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e,hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e) + x);
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e,hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e) + y);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e,hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e) + x);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e,hyperKitGL_io_FloatColorTrianglesUV.get_by(_e) + y);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e,hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e) + x);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e,hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e) + y);
		}, moveDelta : function(dx,dy) {
			hyperKitGL_io_FloatColorTrianglesUV.moveDelta(_e1,dx,dy);
		}, rotateTrig : function(x,y,cos,sin) {
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e2) - x);
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e2) - y);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e2) - x);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_by(_e2) - y);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e2) - x);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e2) - y);
			var dx = hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e2);
			var dy = hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e2);
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e2,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e2,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e2);
			dy = hyperKitGL_io_FloatColorTrianglesUV.get_by(_e2);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e2,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e2,dx * sin + dy * cos);
			dx = hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e2);
			dy = hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e2);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e2,dx * cos - dy * sin);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e2,dx * sin + dy * cos);
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e2) + x);
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e2) + y);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e2) + x);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_by(_e2) + y);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e2) + x);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e2,hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e2) + y);
		}, fullHit : function(px,py) {
			return hyperKitGL_io_FloatColorTrianglesUV.fullHit(_e3,px,py);
		}, liteHit : function(px,py) {
			var planeAB = (hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e4) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_by(_e4) - py) - (hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e4) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e4) - py);
			var planeBC = (hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e4) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e4) - py) - (hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e4) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_by(_e4) - py);
			var planeCA = (hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e4) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e4) - py) - (hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e4) - px) * (hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e4) - py);
			if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
				return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
			} else {
				return false;
			}
		}, get_bottom : function() {
			return Math.max(Math.max(hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e5),hyperKitGL_io_FloatColorTrianglesUV.get_by(_e5)),hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e5));
		}, get_back : function() {
			return Math.max(Math.max(hyperKitGL_io_FloatColorTrianglesUV.get_az(_e6),hyperKitGL_io_FloatColorTrianglesUV.get_bz(_e6)),hyperKitGL_io_FloatColorTrianglesUV.get_cz(_e6));
		}, get_right : function() {
			return Math.max(Math.max(hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e7),hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e7)),hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e7));
		}, get_x : function() {
			return Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e8),hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e8)),hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e8));
		}, set_x : function(x) {
			var dx = x - Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e9),hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e9)),hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e9));
			hyperKitGL_io_FloatColorTrianglesUV.set_ax(_e9,hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e9) + dx);
			hyperKitGL_io_FloatColorTrianglesUV.set_bx(_e9,hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e9) + dx);
			hyperKitGL_io_FloatColorTrianglesUV.set_cx(_e9,hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e9) + dx);
			return x;
		}, get_y : function() {
			return Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e10),hyperKitGL_io_FloatColorTrianglesUV.get_by(_e10)),hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e10));
		}, set_y : function(y) {
			var dy = y - Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e11),hyperKitGL_io_FloatColorTrianglesUV.get_by(_e11)),hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e11));
			hyperKitGL_io_FloatColorTrianglesUV.set_ay(_e11,hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e11) + dy);
			hyperKitGL_io_FloatColorTrianglesUV.set_by(_e11,hyperKitGL_io_FloatColorTrianglesUV.get_by(_e11) + dy);
			hyperKitGL_io_FloatColorTrianglesUV.set_cy(_e11,hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e11) + dy);
			return y;
		}, get_z : function() {
			return Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_az(_e12),hyperKitGL_io_FloatColorTrianglesUV.get_bz(_e12)),hyperKitGL_io_FloatColorTrianglesUV.get_cz(_e12));
		}, set_z : function(z) {
			var dz = z - Math.min(Math.min(hyperKitGL_io_FloatColorTrianglesUV.get_az(_e13),hyperKitGL_io_FloatColorTrianglesUV.get_bz(_e13)),hyperKitGL_io_FloatColorTrianglesUV.get_cz(_e13));
			hyperKitGL_io_FloatColorTrianglesUV.set_az(_e13,hyperKitGL_io_FloatColorTrianglesUV.get_az(_e13) + dz);
			hyperKitGL_io_FloatColorTrianglesUV.set_bz(_e13,hyperKitGL_io_FloatColorTrianglesUV.get_bz(_e13) + dz);
			hyperKitGL_io_FloatColorTrianglesUV.set_cz(_e13,hyperKitGL_io_FloatColorTrianglesUV.get_cz(_e13) + dz);
			return z;
		}, triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return hyperKitGL_io_FloatColorTrianglesUV.triangle(_e14,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e15),hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e15),hyperKitGL_io_FloatColorTrianglesUV.get_az(_e15),1.);
			var pb = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e15),hyperKitGL_io_FloatColorTrianglesUV.get_by(_e15),hyperKitGL_io_FloatColorTrianglesUV.get_bz(_e15),1.);
			var pc = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e15),hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e15),hyperKitGL_io_FloatColorTrianglesUV.get_cz(_e15),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, transform : function(m) {
			trilateral3_geom_FlatColorTrianglesUV.transform(_e16,m);
		}};
		var _e17 = t;
		var _e18 = t;
		var _e19 = t;
		var _e20 = t;
		var _e21 = t;
		var _e22 = t;
		var _e23 = t;
		var _e24 = t;
		var _e25 = t;
		var triangleAbstractUV = { moveDelta : function(du,dv) {
			hyperKitGL_io_FloatColorTrianglesUV.moveDeltaUV(_e17,du,dv);
		}, get_u : function() {
			return Math.min(Math.min(_e18[(_e18[0] | 0) * 27 + 7 + 2],_e18[(_e18[0] | 0) * 27 + 16 + 2]),_e18[(_e18[0] | 0) * 27 + 25 + 2]);
		}, set_u : function(u_) {
			var du = u_ - Math.min(Math.min(_e19[(_e19[0] | 0) * 27 + 7 + 2],_e19[(_e19[0] | 0) * 27 + 16 + 2]),_e19[(_e19[0] | 0) * 27 + 25 + 2]);
			var v = _e19[(_e19[0] | 0) * 27 + 7 + 2] + du;
			_e19[(_e19[0] | 0) * 27 + 7 + 2] = v;
			var v = _e19[(_e19[0] | 0) * 27 + 16 + 2] + du;
			_e19[(_e19[0] | 0) * 27 + 16 + 2] = v;
			var v = _e19[(_e19[0] | 0) * 27 + 25 + 2] + du;
			_e19[(_e19[0] | 0) * 27 + 25 + 2] = v;
			return u_;
		}, get_v : function() {
			return Math.min(Math.min(_e20[(_e20[0] | 0) * 27 + 8 + 2],_e20[(_e20[0] | 0) * 27 + 17 + 2]),_e20[(_e20[0] | 0) * 27 + 26 + 2]);
		}, set_v : function(v_) {
			var dv = v_ - Math.min(Math.min(_e21[(_e21[0] | 0) * 27 + 8 + 2],_e21[(_e21[0] | 0) * 27 + 17 + 2]),_e21[(_e21[0] | 0) * 27 + 26 + 2]);
			var v = _e21[(_e21[0] | 0) * 27 + 8 + 2] + dv;
			_e21[(_e21[0] | 0) * 27 + 8 + 2] = v;
			var v = _e21[(_e21[0] | 0) * 27 + 17 + 2] + dv;
			_e21[(_e21[0] | 0) * 27 + 17 + 2] = v;
			var v = _e21[(_e21[0] | 0) * 27 + 26 + 2] + dv;
			_e21[(_e21[0] | 0) * 27 + 26 + 2] = v;
			return v_;
		}, get_bottomV : function() {
			return Math.max(Math.max(_e22[(_e22[0] | 0) * 27 + 8 + 2],_e22[(_e22[0] | 0) * 27 + 17 + 2]),_e22[(_e22[0] | 0) * 27 + 26 + 2]);
		}, get_rightU : function() {
			return Math.max(Math.max(_e23[(_e23[0] | 0) * 27 + 7 + 2],_e23[(_e23[0] | 0) * 27 + 16 + 2]),_e23[(_e23[0] | 0) * 27 + 25 + 2]);
		}, triangleUV : function(uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_) {
			return hyperKitGL_io_FloatColorTrianglesUV.triangleUV(_e24,uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_);
		}, getTriangleUV : function() {
			var ta = new trilateral3_matrix_UV(_e25[(_e25[0] | 0) * 27 + 7 + 2],_e25[(_e25[0] | 0) * 27 + 8 + 2]);
			var tb = new trilateral3_matrix_UV(_e25[(_e25[0] | 0) * 27 + 16 + 2],_e25[(_e25[0] | 0) * 27 + 17 + 2]);
			var tc = new trilateral3_matrix_UV(_e25[(_e25[0] | 0) * 27 + 25 + 2],_e25[(_e25[0] | 0) * 27 + 26 + 2]);
			return new trilateral3_structure_TriangleUV(ta,tb,tc);
		}};
		var _e26 = t;
		var _e27 = t;
		var _e28 = t;
		var _e29 = t;
		var _e30 = t;
		var _e31 = t;
		var _e32 = t;
		var color3Abstract = { set_argb : function(col) {
			hyperKitGL_io_FloatColorTrianglesUV.set_redA(_e26,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 6 + 2] = v;
			hyperKitGL_io_FloatColorTrianglesUV.set_redB(_e26,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 14 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 13 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 15 + 2] = v;
			hyperKitGL_io_FloatColorTrianglesUV.set_redC(_e26,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 23 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 22 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 24 + 2] = v;
			return col;
		}, set_argbA : function(col) {
			hyperKitGL_io_FloatColorTrianglesUV.set_redA(_e27,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e27[(_e27[0] | 0) * 27 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e27[(_e27[0] | 0) * 27 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e27[(_e27[0] | 0) * 27 + 6 + 2] = v;
			return col;
		}, get_argbA : function() {
			return Math.round(_e28[(_e28[0] | 0) * 27 + 6 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTrianglesUV.get_redA(_e28) * 255) << 16 | Math.round(_e28[(_e28[0] | 0) * 27 + 4 + 2] * 255) << 8 | Math.round(_e28[(_e28[0] | 0) * 27 + 5 + 2] * 255);
		}, set_argbB : function(col) {
			hyperKitGL_io_FloatColorTrianglesUV.set_redB(_e29,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e29[(_e29[0] | 0) * 27 + 14 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e29[(_e29[0] | 0) * 27 + 13 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e29[(_e29[0] | 0) * 27 + 15 + 2] = v;
			return col;
		}, get_argbB : function() {
			return Math.round(_e30[(_e30[0] | 0) * 27 + 15 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTrianglesUV.get_redB(_e30) * 255) << 16 | Math.round(_e30[(_e30[0] | 0) * 27 + 13 + 2] * 255) << 8 | Math.round(_e30[(_e30[0] | 0) * 27 + 14 + 2] * 255);
		}, set_argbC : function(col) {
			hyperKitGL_io_FloatColorTrianglesUV.set_redC(_e31,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e31[(_e31[0] | 0) * 27 + 23 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e31[(_e31[0] | 0) * 27 + 22 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e31[(_e31[0] | 0) * 27 + 24 + 2] = v;
			return col;
		}, get_argbC : function() {
			return Math.round(_e32[(_e32[0] | 0) * 27 + 24 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTrianglesUV.get_redC(_e32) * 255) << 16 | Math.round(_e32[(_e32[0] | 0) * 27 + 22 + 2] * 255) << 8 | Math.round(_e32[(_e32[0] | 0) * 27 + 23 + 2] * 255);
		}};
		var _e33 = t;
		var _e34 = t;
		var _e35 = t;
		var _e36 = t;
		var _e37 = t;
		var _e38 = t;
		var _e39 = t;
		var _e40 = t;
		var _e41 = t;
		var _e42 = t;
		var _e43 = t;
		var _e44 = t;
		var _e45 = t;
		var _e46 = t;
		var _e47 = t;
		var _e48 = t;
		var _e49 = t;
		var _e50 = t;
		var paintAbstract = { triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return hyperKitGL_io_FloatColorTrianglesUV.triangle(_e33,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, triangleUV : function(uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_) {
			return hyperKitGL_io_FloatColorTrianglesUV.triangleUV(_e34,uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_);
		}, cornerColors : function(colorA,colorB,colorC) {
			hyperKitGL_io_FloatColorTrianglesUV.set_redA(_e35,(colorA >> 16 & 255) / 255);
			var v = (colorA & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 5 + 2] = v;
			var v = (colorA >> 8 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 4 + 2] = v;
			var v = (colorA >> 24 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 6 + 2] = v;
			hyperKitGL_io_FloatColorTrianglesUV.set_redB(_e35,(colorB >> 16 & 255) / 255);
			var v = (colorB & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 14 + 2] = v;
			var v = (colorB >> 8 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 13 + 2] = v;
			var v = (colorB >> 24 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 15 + 2] = v;
			hyperKitGL_io_FloatColorTrianglesUV.set_redC(_e35,(colorC >> 16 & 255) / 255);
			var v = (colorC & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 23 + 2] = v;
			var v = (colorC >> 8 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 22 + 2] = v;
			var v = (colorC >> 24 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 24 + 2] = v;
		}, colorTriangles : function(color,times) {
			var _g = 0;
			var _g1 = times;
			while(_g < _g1) {
				var i = _g++;
				hyperKitGL_io_FloatColorTrianglesUV.set_redA(_e36,(color >> 16 & 255) / 255);
				var v = (color & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 5 + 2] = v;
				var v1 = (color >> 8 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 4 + 2] = v1;
				var v2 = (color >> 24 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 6 + 2] = v2;
				hyperKitGL_io_FloatColorTrianglesUV.set_redB(_e36,(color >> 16 & 255) / 255);
				var v3 = (color & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 14 + 2] = v3;
				var v4 = (color >> 8 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 13 + 2] = v4;
				var v5 = (color >> 24 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 15 + 2] = v5;
				hyperKitGL_io_FloatColorTrianglesUV.set_redC(_e36,(color >> 16 & 255) / 255);
				var v6 = (color & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 23 + 2] = v6;
				var v7 = (color >> 8 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 22 + 2] = v7;
				var v8 = (color >> 24 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 24 + 2] = v8;
			}
		}, getTriInt : function() {
			return new trilateral3_structure_TriInt(Math.round(_e37[(_e37[0] | 0) * 27 + 6 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTrianglesUV.get_redA(_e37) * 255) << 16 | Math.round(_e37[(_e37[0] | 0) * 27 + 4 + 2] * 255) << 8 | Math.round(_e37[(_e37[0] | 0) * 27 + 5 + 2] * 255),Math.round(_e37[(_e37[0] | 0) * 27 + 15 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTrianglesUV.get_redB(_e37) * 255) << 16 | Math.round(_e37[(_e37[0] | 0) * 27 + 13 + 2] * 255) << 8 | Math.round(_e37[(_e37[0] | 0) * 27 + 14 + 2] * 255),Math.round(_e37[(_e37[0] | 0) * 27 + 24 + 2] * 255) << 24 | Math.round(hyperKitGL_io_FloatColorTrianglesUV.get_redC(_e37) * 255) << 16 | Math.round(_e37[(_e37[0] | 0) * 27 + 22 + 2] * 255) << 8 | Math.round(_e37[(_e37[0] | 0) * 27 + 23 + 2] * 255));
		}, transform : function(m) {
			trilateral3_geom_FlatColorTrianglesUV.transform(_e38,m);
		}, transformRange : function(m,startEnd) {
			trilateral3_geom_FlatColorTrianglesUV.transformRange(_e39,m,startEnd);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_ax(_e40),hyperKitGL_io_FloatColorTrianglesUV.get_ay(_e40),hyperKitGL_io_FloatColorTrianglesUV.get_az(_e40),1.);
			var pb = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_bx(_e40),hyperKitGL_io_FloatColorTrianglesUV.get_by(_e40),hyperKitGL_io_FloatColorTrianglesUV.get_bz(_e40),1.);
			var pc = new trilateral3_matrix_Vertex(hyperKitGL_io_FloatColorTrianglesUV.get_cx(_e40),hyperKitGL_io_FloatColorTrianglesUV.get_cy(_e40),hyperKitGL_io_FloatColorTrianglesUV.get_cz(_e40),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, getTriangleUV : function() {
			var ta = new trilateral3_matrix_UV(_e41[(_e41[0] | 0) * 27 + 7 + 2],_e41[(_e41[0] | 0) * 27 + 8 + 2]);
			var tb = new trilateral3_matrix_UV(_e41[(_e41[0] | 0) * 27 + 16 + 2],_e41[(_e41[0] | 0) * 27 + 17 + 2]);
			var tc = new trilateral3_matrix_UV(_e41[(_e41[0] | 0) * 27 + 25 + 2],_e41[(_e41[0] | 0) * 27 + 26 + 2]);
			return new trilateral3_structure_TriangleUV(ta,tb,tc);
		}, next : function() {
			var pos_ = _e42[0] + 1.;
			_e42[0] = pos_;
			if(_e42[0] > _e42[1] - 1) {
				_e42[1] = _e42[0];
			}
			return _e42[0];
		}, hasNext : function() {
			return _e43[0] < hyperKitGL_io_Float32Flat.get_size(_e43);
		}, get_pos : function() {
			return _e44[0];
		}, set_pos : function(pos_) {
			_e45[0] = pos_;
			if(_e45[0] > _e45[1] - 1) {
				_e45[1] = _e45[0];
			}
			return pos_;
		}, get_size : function() {
			return hyperKitGL_io_Float32Flat.get_size(_e46);
		}, set_size : function(id) {
			return hyperKitGL_io_Float32Flat.set_size(_e47,id);
		}, toStart : function(id,len) {
			var starting = id * 27;
			var totalLen = 27 * len | 0;
			if(starting == 0) {
				return false;
			} else {
				var ending = starting + totalLen;
				var temp = [];
				var count = 0;
				var _g = starting;
				var _g1 = ending;
				while(_g < _g1) {
					var i = _g++;
					temp[count] = _e48[i + 2];
					++count;
				}
				count = totalLen;
				var _g = 0;
				var _g1 = starting;
				while(_g < _g1) {
					var i = _g++;
					var v = _e48[starting - 1 - i + 2];
					_e48[ending - 1 - i + 2] = v;
				}
				count = 0;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					var v = temp[count - 2];
					_e48[i + 2] = v;
					++count;
				}
				temp = null;
				return true;
			}
		}, toEnd : function(id,len) {
			return hyperKitGL_io_Float32FlatDepth.rangeToEnd(_e49,id * 27,27 * len | 0,27);
		}, swap : function(id0,id1,len) {
			var start0 = id0 * 21;
			var start1 = id1 * 21;
			var totalLen = 21 * len | 0;
			if(start0 + totalLen > hyperKitGL_io_Float32Flat.get_size(_e50) && start1 + totalLen > hyperKitGL_io_Float32Flat.get_size(_e50)) {
				var temp0;
				var temp1;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					temp0 = _e50[start0 + i + 2];
					temp1 = _e50[start1 + i + 2];
					_e50[start0 + i + 2] = temp1;
					_e50[start1 + i + 2] = temp0;
				}
				return true;
			} else {
				return false;
			}
		}, triangleCurrent : triangleAbstract, triangleCurrentUV : triangleAbstractUV, color3current : color3Abstract};
		this.pen = new trilateral3_drawing_Pen(paintAbstract);
	}
	,get_data: function() {
		var this1 = this.colorTriangles;
		return this1.subarray(2,hyperKitGL_io_Float32Flat.get_size(this1) * 27 + 2);
	}
	,get_size: function() {
		return hyperKitGL_io_Float32Flat.get_size(this.colorTriangles) * 3 | 0;
	}
};
var trilateral3_reShape_QuadShaper = function(pen,start,wid,hi) {
	if(hi == null) {
		hi = 1000;
	}
	if(wid == null) {
		wid = 1000;
	}
	this.pen = pen;
	this.start = start;
	this.tri = new trilateral3_reShape_TrianglesShaper(pen,wid,hi);
};
trilateral3_reShape_QuadShaper.__name__ = true;
trilateral3_reShape_QuadShaper.prototype = {
	drawQuad: function(u,v,w,h) {
		var _this = this.pen;
		var bx = u + w;
		var dy = v + h;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		var color1 = color;
		if(color1 == null) {
			color1 = -1;
		}
		if(color1 == -1) {
			color1 = _this.currentColor;
		}
		var ax = u;
		var ay = v;
		var bx1 = bx;
		var by = v;
		var cx = u;
		var cy = dy;
		var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx1,by,_this.z2D,cx,cy,_this.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx1 /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this.paintType.triangleUV(ax,ay,bx1,by,cx,cy,windAdjust);
		}
		_this.paintType.cornerColors(color1,color1,color1);
		_this.paintType.next();
		var color1 = color;
		if(color1 == null) {
			color1 = -1;
		}
		if(color1 == -1) {
			color1 = _this.currentColor;
		}
		var ax = bx;
		var ay = v;
		var bx = u + w;
		var by = v + h;
		var cx = u;
		var cy = dy;
		var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this.paintType.cornerColors(color1,color1,color1);
		_this.paintType.next();
	}
};
var trilateral3_reShape_RangeShaper = function(pen,iteratorRange,wid,hi) {
	if(hi == null) {
		hi = 1000;
	}
	if(wid == null) {
		wid = 1000;
	}
	this.pv = 10000000000;
	this.pu = 10000000000;
	this.py = 10000000000;
	this.px = 10000000000;
	this.pen = pen;
	this.range = iteratorRange;
	this.tri = new trilateral3_reShape_TrianglesShaper(pen,wid,hi);
	var this1 = this.range;
	var _g_min = this1.start;
	var _g_max = this1.max;
	while(_g_min < _g_max) {
		var i = _g_min++;
		pen.paintType.set_pos(i);
		var _this = this.tri;
		if(_this.curr.get_x() * _this.wid + _this.wid < this.px) {
			var _this1 = this.tri;
			this.px = _this1.curr.get_x() * _this1.wid + _this1.wid;
		}
		var _this2 = this.tri;
		if(-(_this2.curr.get_y() * _this2.hi - _this2.hi) < this.py) {
			var _this3 = this.tri;
			this.py = -(_this3.curr.get_y() * _this3.hi - _this3.hi);
		}
		if(this.tri.currUV != null) {
			if(-this.tri.currUV.get_u() * 1000 < this.pu) {
				this.pu = -this.tri.currUV.get_u() * 1000;
			}
			if(-this.tri.currUV.get_v() * 1000 < this.pv) {
				this.pv = -this.tri.currUV.get_v() * 1000;
			}
		}
	}
};
trilateral3_reShape_RangeShaper.__name__ = true;
var trilateral3_reShape_TrianglesShaper = function(pen,wid,hi) {
	if(hi == null) {
		hi = 1000;
	}
	if(wid == null) {
		wid = 1000;
	}
	this.pen = pen;
	this.wid = wid;
	this.hi = hi;
	this.curr = pen.paintType.triangleCurrent;
	if(pen.paintType.triangleCurrentUV != null) {
		this.currUV = pen.paintType.triangleCurrentUV;
	}
	this.curr3color = pen.paintType.color3current;
};
trilateral3_reShape_TrianglesShaper.__name__ = true;
var trilateral3_shape_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
trilateral3_shape_IntIterStart.__name__ = true;
var trilateral3_structure_RangeEntity = function(textured,range,bgColor) {
	if(bgColor == null) {
		bgColor = -1;
	}
	this.bgColor = -1;
	this.textured = textured;
	this.range = range;
	this.bgColor = bgColor;
};
trilateral3_structure_RangeEntity.__name__ = true;
var trilateral3_structure_StartEnd = function(start,end) {
	this.start = start;
	this.end = end;
};
trilateral3_structure_StartEnd.__name__ = true;
var trilateral3_structure_TriInt = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_TriInt.__name__ = true;
var trilateral3_structure_Triangle3D = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_Triangle3D.__name__ = true;
var trilateral3_structure_TriangleUV = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_TriangleUV.__name__ = true;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_WindingRule);
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_ResultType);
js_Boot.__toStr = ({ }).toString;
hxGeomAlgo_HxPoint.EMPTY = hxGeomAlgo_HxPoint._new(NaN,NaN);
hxGeomAlgo_PolyTools.point = hxGeomAlgo_HxPoint._new();
hxGeomAlgo_PolyTools.zero = hxGeomAlgo_HxPoint._new(0,0);
hxGeomAlgo_PolyTools.EPSILON = .00000001;
hyperKitGL_AnimateTimer.counter = 0;
org_poly2tri_Constants.kAlpha = 0.3;
org_poly2tri_Constants.EPSILON = 1e-12;
org_poly2tri_Constants.PI_2 = Math.PI / 2;
org_poly2tri_Constants.PI_3div4 = 3 * Math.PI / 4;
org_poly2tri_Point.C_ID = 0;
trilateral3_nodule_PenNodule.largeEnough = 20000000;
trilateral3_nodule_PenPaint.largeEnough = 20000000;
hyperKitGLsamples_basic_Main_main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
